BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:globasciiranges:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=([0]="0")
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_VERSINFO=([0]="2" [1]="10")
BASH_LINENO=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="5" [1]="0" [2]="16" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='5.0.16(1)-release'
COLUMNS=160
DIRSTACK=()
EUID=1000
GROUPS=()
HISTCONTROL=ignoreboth
HISTFILE=/home/lfabbri/.bash_history
HISTFILESIZE=2000
HISTSIZE=1000
HOME=/home/lfabbri
HOSTNAME=TINETRCH2004291
HOSTTYPE=x86_64
IFS=$' \t\n'
LANG=C.UTF-8
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=14
LOGNAME=lfabbri
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:'
MACHTYPE=x86_64-pc-linux-gnu
MAILCHECK=60
NAME=TINETRCH2004291
NVM_BIN=/home/lfabbri/.nvm/versions/node/v14.19.1/bin
NVM_CD_FLAGS=
NVM_DIR=/home/lfabbri/.nvm
NVM_INC=/home/lfabbri/.nvm/versions/node/v14.19.1/include/node
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH='/home/lfabbri/.nvm/versions/node/v14.19.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/mnt/c/Program Files/Eclipse Adoptium/jdk-17.0.5.8-hotspot/bin:/mnt/c/Program Files/Eclipse Foundation/jdk-8.0.302.8-hotspot/bin:/mnt/c/Program Files/Microsoft/jdk-11.0.12.7-hotspot/bin:/mnt/c/Python39/Scripts/:/mnt/c/Python39/:/mnt/c/Program Files/AdoptOpenJDK/jre-15.0.2.7-hotspot/bin:/mnt/c/Program Files/AdoptOpenJDK/jdk-11.0.8.10-hotspot/bin:/mnt/c/Program Files (x86)/Common Files/Oracle/Java/javapath:/mnt/c/WINDOWS/system32:/mnt/c/WINDOWS:/mnt/c/WINDOWS/System32/Wbem:/mnt/c/WINDOWS/System32/WindowsPowerShell/v1.0/:/mnt/c/WINDOWS/System32/OpenSSH/:/mnt/c/Program Files/Microsoft SQL Server/130/Tools/Binn/:/mnt/c/Program Files/Microsoft SQL Server/Client SDK/ODBC/170/Tools/Binn/:/mnt/c/ProgramData/ComposerSetup/bin:/mnt/c/Program Files/Microsoft SQL Server/Client SDK/ODBC/130/Tools/Binn/:/mnt/c/Program Files (x86)/Microsoft SQL Server/140/Tools/Binn/:/mnt/c/Program Files/Microsoft SQL Server/140/Tools/Binn/:/mnt/c/Program Files/Microsoft SQL Server/140/DTS/Binn/:/mnt/c/Program Files (x86)/Microsoft SQL Server/150/DTS/Binn/:/mnt/c/Program Files/PuTTY/:/mnt/c/Program Files/Amazon/AWSCLIV2/:/mnt/c/ProgramData/chocolatey/bin:/mnt/c/Library/Developer/Toolchains/unknown-Asserts-development.xctoolchain/usr/bin:/mnt/c/Library/Swift-development/bin:/mnt/c/Library/icu-67/usr/bin:/mnt/c/Program Files/Microsoft SQL Server/150/Tools/Binn/:/mnt/c/Program Files/dotnet/:/mnt/c/WINDOWS/system32:/mnt/c/WINDOWS:/mnt/c/WINDOWS/System32/Wbem:/mnt/c/WINDOWS/System32/WindowsPowerShell/v1.0/:/mnt/c/WINDOWS/System32/OpenSSH/:/mnt/c/Users/lfabbri/AppData/Roaming/nvm:/mnt/c/Program Files/nodejs:/mnt/c/Strawberry/c/bin:/mnt/c/Strawberry/perl/site/bin:/mnt/c/Strawberry/perl/bin:/mnt/c/Program Files/Docker/Docker/resources/bin:/mnt/c/ProgramData/DockerDesktop/version-bin:/mnt/c/Program Files/Git/cmd:/mnt/c/ProgramData/chocolatey/lib/maven/apache-maven-3.8.6/bin:/mnt/c/Ruby31-x64/bin:/mnt/c/Program Files/MySQL/MySQL Shell 8.0/bin/:/mnt/c/Users/lfabbri/AppData/Local/Microsoft/WindowsApps:/mnt/c/Users/lfabbri/AppData/Local/Programs/Microsoft VS Code/bin:/mnt/c/Users/lfabbri/AppData/Local/GitHubDesktop/bin:/mnt/c/Tools/platform-tools:/mnt/c/xampp/php:/mnt/c/Users/lfabbri/AppData/Roaming/Composer/vendor/bin:/mnt/c/Users/lfabbri/.dotnet/tools:/mnt/c/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin:/mnt/c/Users/lfabbri/AppData/Local/Programs/Azure Data Studio/bin:/mnt/c/Users/lfabbri/AppData/Local/Packages/PythonSoftwareFoundation.Python.3.8_qbz5n2kfra8p0/LocalCache/local-packages/Python38/Scripts:/mnt/c/telosys-cli:/mnt/c/Program Files/MySQL/MySQL Server 8.0/bin:/mnt/c/cygwin64/bin:/mnt/c/Users/lfabbri/AppData/Local/Microsoft/WindowsApps:/mnt/c/Gradle/gradle-6.8.3/bin:/mnt/c/wp-cli:/mnt/c/ProgramData/lfabbri/GitHubDesktop/bin:/mnt/c/Users/lfabbri/AppData/Roaming/nvm:/mnt/c/Program Files/nodejs:/mnt/c/flutter/bin:/mnt/c/JavaLibs:/mnt/c/JavaLibs/antlr-4.11.1-complete.jar:/snap/bin'
PIPESTATUS=([0]="0")
PPID=7
PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
PS2='> '
PS4='+ '
PWD=/mnt/c/Users/lfabbri/projects/api-query-language/raql-ts/RAQL.TS
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
TERM=xterm-256color
UID=1000
USER=lfabbri
WSLENV=
WSL_DISTRO_NAME=Ubuntu
XDG_DATA_DIRS=/usr/local/share:/usr/share:/var/lib/snapd/desktop
_=echo
__git_printf_supports_v=yes
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_xspecs=([lokalize]="!*.po" [acroread]="!*.[pf]df" [lbzcat]="!*.?(t)bz?(2)" [mpg321]="!*.mp3" [bzcat]="!*.?(t)bz?(2)" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [unlzma]="!*.@(tlz|lzma)" [sxemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [aviplay]="!*.@(avi|asf|wmv)" [lbunzip2]="!*.?(t)bz?(2)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [freeamp]="!*.@(mp3|og[ag]|pls|m3u)" [rgvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [gqmpeg]="!*.@(mp3|og[ag]|pls|m3u)" [texi2html]="!*.texi*" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [dvitype]="!*.dvi" [lobase]="!*.odb" [rpm2cpio]="!*.[rs]pm" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [lualatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [localc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [hbrun]="!*.[Hh][Rr][Bb]" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [unpigz]="!*.@(Z|[gGdz]z|t[ag]z)" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [epdfview]="!*.pdf" [dvips]="!*.dvi" [pdfunite]="!*.pdf" [ps2pdf14]="!*.@(?(e)ps|pdf)" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [vi]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ps2pdf]="!*.@(?(e)ps|pdf)" [gpdf]="!*.[pf]df" [lilypond]="!*.ly" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [znew]="*.Z" [ps2pdf13]="!*.@(?(e)ps|pdf)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [kwrite]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [kate]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [pbzcat]="!*.?(t)bz?(2)" [poedit]="!*.po" [view]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [luatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [bunzip2]="!*.?(t)bz?(2)" [dvipdfm]="!*.dvi" [kbabel]="!*.po" [ly2dvi]="!*.ly" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [bzme]="!*.@(zip|z|gz|tgz)" [rgview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [xemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [rvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [madplay]="!*.mp3" [xetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [dviselect]="!*.dvi" [kpdf]="!*.@(?(e)ps|pdf)" [bibtex]="!*.aux" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [mpg123]="!*.mp3" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [lzegrep]="!*.@(tlz|lzma)" [gview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [xv]="!*.@(gif|jp?(e)g?(2)|j2[ck]|jp[2f]|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [lzfgrep]="!*.@(tlz|lzma)" [playmidi]="!*.@(mid?(i)|cmf)" [lzless]="!*.@(tlz|lzma)" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [xfig]="!*.fig" [xpdf]="!*.@(pdf|fdf)?(.@(gz|GZ|bz2|BZ2|Z))" [lomath]="!*.@(sxm|smf|mml|odf)" [lzcat]="!*.@(tlz|lzma)" [compress]="*.Z" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [pbunzip2]="!*.?(t)bz?(2)" [oobase]="!*.odb" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [gtranslator]="!*.po" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [emacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [zipinfo]="!*.@(zip|[egjswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl)" [xelatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [uncompress]="!*.Z" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [unzip]="!*.@(zip|[egjswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl)" [rview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [lrunzip]="!*.lrz" [lzgrep]="!*.@(tlz|lzma)" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [vim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [oomath]="!*.@(sxm|smf|mml|odf)" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [dvipdfmx]="!*.dvi" [advi]="!*.dvi" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [makeinfo]="!*.texi*" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2|xz|XZ)))" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lzmore]="!*.@(tlz|lzma)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [loimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [dvipdf]="!*.dvi" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" )
snap_bin_path=/snap/bin
snap_xdg_path=/var/lib/snapd/desktop
__expand_tilde_by_ref () 
{ 
    if [[ ${!1} == \~* ]]; then
        eval $1=$(printf ~%q "${!1#\~}");
    fi
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i ))
        do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                cur="${cur:1}";
                [[ $index -gt 0 ]] && ((index--));
            done;
            if [[ $i -lt $cword ]]; then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                (( index -= old_size - new_size ));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ $index -lt 0 ]] && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
}
__git_eread () 
{ 
    test -r "$1" && IFS='
' read "$2" < "$1"
}
__git_ps1 () 
{ 
    local exit=$?;
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}";
            PS1="$ps1pc_start$ps1pc_end"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return $exit
        ;;
    esac;
    local ps1_expanded=yes;
    [ -z "${ZSH_VERSION-}" ] || [[ -o PROMPT_SUBST ]] || ps1_expanded=no;
    [ -z "${BASH_VERSION-}" ] || shopt -q promptvars || ps1_expanded=no;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        return $exit;
    fi;
    local short_sha="";
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    if [ "true" = "$inside_worktree" ] && [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] && [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] && git check-ignore -q .; then
        return $exit;
    fi;
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        __git_eread "$g/rebase-merge/head-name" b;
        __git_eread "$g/rebase-merge/msgnum" step;
        __git_eread "$g/rebase-merge/end" total;
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            __git_eread "$g/rebase-apply/next" step;
            __git_eread "$g/rebase-apply/last" total;
            if [ -f "$g/rebase-apply/rebasing" ]; then
                __git_eread "$g/rebase-apply/head-name" b;
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if __git_sequencer_status; then
                    :;
                else
                    if [ -f "$g/BISECT_LOG" ]; then
                        r="|BISECTING";
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! __git_eread "$g/HEAD" head; then
                    return $exit;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(tag)
					git describe --tags HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet || w="*";
                git diff --no-ext-diff --cached --quiet || i="+";
                if [ -z "$short_sha" ] && [ -z "$i" ]; then
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && git rev-parse --verify --quiet refs/stash > /dev/null; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    b=${b##refs/heads/};
    if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
        __git_ps1_branch_name=$b;
        b="\${__git_ps1_branch_name}";
    fi;
    local f="$w$i$s$u";
    local gitstring="$c$b${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi;
    return $exit
}
__git_ps1_colorize_gitstring () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            __git_ps1_upstream_name=$(git rev-parse 				--abbrev-ref "$upstream" 2>/dev/null);
            if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
                p="$p \${__git_ps1_upstream_name}";
            else
                p="$p ${__git_ps1_upstream_name}";
                unset __git_ps1_upstream_name;
            fi;
        fi;
    fi
}
__git_sequencer_status () 
{ 
    local todo;
    if test -f "$g/CHERRY_PICK_HEAD"; then
        r="|CHERRY-PICKING";
        return 0;
    else
        if test -f "$g/REVERT_HEAD"; then
            r="|REVERTING";
            return 0;
        else
            if __git_eread "$g/sequencer/todo" todo; then
                case "$todo" in 
                    p[\ \	] | pick[\ \	]*)
                        r="|CHERRY-PICKING";
                        return 0
                    ;;
                    revert[\ \	]*)
                        r="|REVERTING";
                        return 0
                    ;;
                esac;
            fi;
        fi;
    fi;
    return 1
}
__load_completion () 
{ 
    local -a dirs=(${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions);
    local OIFS=$IFS IFS=: dir cmd="${1##*/}" compfile;
    [[ -n $cmd ]] || return 1;
    for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share};
    do
        dirs+=($dir/bash-completion/completions);
    done;
    IFS=$OIFS;
    if [[ $BASH_SOURCE == */* ]]; then
        dirs+=("${BASH_SOURCE%/*}/completions");
    else
        dirs+=(./completions);
    fi;
    for dir in "${dirs[@]}";
    do
        [[ -d "$dir" ]] || continue;
        for compfile in "$cmd" "$cmd.bash" "_$cmd";
        do
            compfile="$dir/$compfile";
            [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 0;
        done;
    done;
    [[ -n "${_xspecs[$cmd]}" ]] && complete -F _filedir_xspec "$cmd" && return 0;
    return 1
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while [[ $((--i)) -ge 0 ]]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__nvm () 
{ 
    declare previous_word;
    previous_word="${COMP_WORDS[COMP_CWORD - 1]}";
    case "${previous_word}" in 
        use | run | exec | ls | list | uninstall)
            __nvm_installed_nodes
        ;;
        alias | unalias)
            __nvm_alias
        ;;
        *)
            __nvm_commands
        ;;
    esac;
    return 0
}
__nvm_alias () 
{ 
    __nvm_generate_completion "$(__nvm_aliases)"
}
__nvm_aliases () 
{ 
    declare aliases;
    aliases="";
    if [ -d "${NVM_DIR}/alias" ]; then
        aliases="$(cd "${NVM_DIR}/alias" && command find "${PWD}" -type f | command sed "s:${PWD}/::")";
    fi;
    echo "${aliases} node stable unstable iojs"
}
__nvm_commands () 
{ 
    declare current_word;
    declare command;
    current_word="${COMP_WORDS[COMP_CWORD]}";
    COMMANDS='
    help install uninstall use run exec
    alias unalias reinstall-packages
    current list ls list-remote ls-remote
    install-latest-npm
    cache deactivate unload
    version version-remote which';
    if [ ${#COMP_WORDS[@]} == 4 ]; then
        command="${COMP_WORDS[COMP_CWORD - 2]}";
        case "${command}" in 
            alias)
                __nvm_installed_nodes
            ;;
        esac;
    else
        case "${current_word}" in 
            -*)
                __nvm_options
            ;;
            *)
                __nvm_generate_completion "${COMMANDS}"
            ;;
        esac;
    fi
}
__nvm_generate_completion () 
{ 
    declare current_word;
    current_word="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=($(compgen -W "$1" -- "${current_word}"));
    return 0
}
__nvm_installed_nodes () 
{ 
    __nvm_generate_completion "$(nvm_ls) $(__nvm_aliases)"
}
__nvm_options () 
{ 
    OPTIONS='';
    __nvm_generate_completion "${OPTIONS}"
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    local -a array=($1);
    for i in "${array[@]}";
    do
        case "$i" in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    printf -v "$3" %s "$COMP_CWORD";
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
                [[ $line != [[:blank:]]* ]] && (( j >= 2 )) && ((j--));
                ref="$2[$j]";
                printf -v "$ref" %s "${!ref}${COMP_WORDS[i]}";
                [[ $i == $COMP_CWORD ]] && printf -v "$3" %s "$j";
                line=${line#*"${COMP_WORDS[$i]}"};
                [[ $line == [[:blank:]]* ]] && ((j++));
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            printf -v "$ref" %s "${!ref}${COMP_WORDS[i]}";
            line=${line#*"${COMP_WORDS[i]}"};
            [[ $i == $COMP_CWORD ]] && printf -v "$3" %s "$j";
        done;
        [[ $i == $COMP_CWORD ]] && printf -v "$3" %s "$j";
    else
        for i in "${!COMP_WORDS[@]}";
        do
            printf -v "$2[i]" %s "${COMP_WORDS[i]}";
        done;
    fi
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($(compgen -g -- "$1"));
    else
        local IFS='
 ';
        COMPREPLY=($(compgen -W             "$(id -Gn 2>/dev/null || groups 2>/dev/null)" -- "$1"));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($(compgen -u -- "${1:-$cur}"));
    else
        local IFS='
 ';
        COMPREPLY=($(compgen -W             "$(id -un 2>/dev/null || whoami 2>/dev/null)" -- "${1:-$cur}"));
    fi
}
_apport-bug () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help --save -v --version --tag -w --window';
    case "$prev" in 
        ubuntu-bug | apport-bug)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions="--tag";
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-cli () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
                 -c --crash-file --save -v --version --tag -w --window';
    case "$prev" in 
        apport-cli)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions='--tag';
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--symptom.* || "${COMP_WORDS[*]}" =~ .*\ -s\ .* ]]; then
                dashoptions="-s --symptom $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--update.* || "${COMP_WORDS[*]}" =~ .*\ -u\ .* ]]; then
                dashoptions="-u --update $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--file-bug.* || "${COMP_WORDS[*]}" =~ .*\ -f\ .* ]]; then
                dashoptions="-f --file-bug $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--crash-file.* || "${COMP_WORDS[*]}" =~ .*\ -c\ .* ]]; then
                dashoptions="-c --crash-file $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-collect () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-collect)
            COMPREPLY=($( compgen -W "-p --package --tag" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
        --tag)
            return 0
        ;;
        *)
            if [[ "${COMP_WORDS[*]}" =~ .*\ -p.* || "${COMP_WORDS[*]}" =~ .*--package.* ]]; then
                COMPREPLY=($( compgen -W "--tag" -- $cur));
            else
                COMPREPLY=($( compgen -W "-p --package --tag" -- $cur));
            fi
        ;;
    esac
}
_apport-unpack () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-unpack)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
    esac
}
_apport_parameterless () 
{ 
    local param;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*" )";
    COMPREPLY=($( compgen -W "$param" -- $cur))
}
_apport_symptoms () 
{ 
    local syms;
    if [ -r /usr/share/apport/symptoms ]; then
        for FILE in $(ls /usr/share/apport/symptoms);
        do
            if [[ ! "$FILE" =~ ^_.* && -n $(egrep "^def run\s*\(.*\):" /usr/share/apport/symptoms/$FILE) ]]; then
                syms="$syms ${FILE%.py}";
            fi;
        done;
    fi;
    echo $syms
}
_available_interfaces () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY=($({
        if [[ ${1:-} == -w ]]; then
            iwconfig
        elif [[ ${1:-} == -a ]]; then
            ifconfig || ip link show up
        else
            ifconfig -a || ip link show
        fi
    } 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }'));
    COMPREPLY=($(compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur"))
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $(compgen -d -- $i/$cur);
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return
}
_cd_devices () 
{ 
    COMPREPLY+=($(compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}"))
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i=0; i < $word_offset; i++ ))
    do
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        do
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT-=${#COMP_WORDS[i]}));
    done;
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset 'COMP_WORDS[i]';
    done;
    ((COMP_CWORD -= $word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($(compgen -d -c -- "$cur"));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$(complete -p $cmd 2>/dev/null);
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$(complete -p ${cmd##*/} 2>/dev/null);
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$(complete -p $compcmd 2>/dev/null);
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($(eval compgen "$cspec" -- '$cur'));
            fi;
        else
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
                _minimal;
            fi;
        fi;
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_completion_loader () 
{ 
    local cmd="${1:-_EmptycmD_}";
    __load_completion "$cmd" && return 124;
    complete -F _minimal -- "$cmd" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($(compgen -W "$(command sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces /etc/network/interfaces.d/* 2>/dev/null)"             -- "$cur"));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($(compgen -W "$(printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($(compgen -W "$(command ls -B             /etc/sysconfig/interfaces |             command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
            else
                COMPREPLY=($(compgen -W "$(printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for ((i=1; i < cword; i++ ))
    do
        if [[ ${words[i]} != -* && ${words[i-1]} != $2 || ${words[i]} == $3 ]]; then
            (( args++ ));
        fi;
    done
}
_dvd_devices () 
{ 
    COMPREPLY+=($(compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}"))
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        __expand_tilde_by_ref cur;
    else
        if [[ "$cur" == \~* ]]; then
            _tilde "$cur" || eval COMPREPLY[0]=$(printf ~%q "${COMPREPLY[0]#\~}");
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_filedir () 
{ 
    local IFS='
';
    _tilde "$cur" || return;
    local -a toks;
    local reset;
    if [[ "$1" == -d ]]; then
        reset=$(shopt -po noglob);
        set -o noglob;
        toks=($(compgen -d -- "$cur"));
        IFS=' ';
        $reset;
        IFS='
';
    else
        local quoted;
        _quote_readline_by_ref "$cur" quoted;
        local xspec=${1:+"!*.@($1|${1^^})"} plusdirs=();
        local opts=(-f -X "$xspec");
        [[ -n $xspec ]] && plusdirs=(-o plusdirs);
        [[ -n ${COMP_FILEDIR_FALLBACK-} ]] || opts+=("${plusdirs[@]}");
        reset=$(shopt -po noglob);
        set -o noglob;
        toks+=($(compgen "${opts[@]}" -- $quoted));
        IFS=' ';
        $reset;
        IFS='
';
        [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && ${#toks[@]} -lt 1 ]] && { 
            reset=$(shopt -po noglob);
            set -o noglob;
            toks+=($(compgen -f "${plusdirs[@]}" -- $quoted));
            IFS=' ';
            $reset;
            IFS='
'
        };
    fi;
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "'!$xspec'" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [[ -n $tmp ]] && printf '%s\n' $tmp
        done
        }
        ));
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && ${#toks[@]} -lt 1 ]] && { 
        local reset=$(shopt -po noglob);
        set -o noglob;
        toks+=($(compgen -f -- "$(quote_readline "$cur")"));
        IFS=' ';
        $reset;
        IFS='
'
    };
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$(cut -d'	' -f2 /proc/filesystems)
             $(awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null)";
    else
        fss="$(awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null)
             $(awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null)
             $(awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null)
             $(awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null)
             $([[ -d /etc/fs ]] && command ls /etc/fs)";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($(compgen -W "$fss" -- "$cur"))
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash_completion: $FUNCNAME: \`${!OPTIND}':" "unknown argument" 1>&2;
                return 1
            ;;
        esac;
        (( OPTIND += 1 ));
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    [[ $index -gt 0 ]] && ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    (( index -= old_size - new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if [[ $COMP_CWORD -ge 1 ]]; then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($(compgen -W '$(getent group | cut -d: -f3)' -- "$cur"));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($(compgen -W '$(perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"')' -- "$cur"));
        else
            COMPREPLY=($(compgen -W '$(cut -d: -f3 /etc/group)' -- "$cur"));
        fi;
    fi
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_included_ssh_config_files () 
{ 
    [[ $# -lt 1 ]] && echo "bash_completion: $FUNCNAME: missing mandatory argument CONFIG" 1>&2;
    local configfile i f;
    configfile=$1;
    local included=($(command sed -ne 's/^[[:blank:]]*[Ii][Nn][Cc][Ll][Uu][Dd][Ee][[:blank:]]\{1,\}\([^#%]*\)\(#.*\)\{0,1\}$/\1/p' "${configfile}"));
    for i in "${included[@]}";
    do
        if ! [[ "$i" =~ ^\~.*|^\/.* ]]; then
            if [[ "$configfile" =~ ^\/etc\/ssh.* ]]; then
                i="/etc/ssh/$i";
            else
                i="$HOME/.ssh/$i";
            fi;
        fi;
        __expand_tilde_by_ref i;
        for f in ${i};
        do
            if [ -r $f ]; then
                config+=("$f");
                _included_ssh_config_files $f;
            fi;
        done;
    done
}
_init_completion () 
{ 
    local exclude="" flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || $prev == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=$errx
            ;;
            *'>'*)
                xspec=$outx
            ;;
            *'<'*)
                xspec=$inx
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=$errx
                    ;;
                    *'>'*)
                        xspec=$outx
                    ;;
                    *'<'*)
                        xspec=$inx
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            [[ $i -le $cword ]] && (( cword -= skip ));
        else
            (( i++ ));
        fi;
    done;
    [[ $cword -le 0 ]] && return 1;
    prev=${words[cword-1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($(compgen -W "$(PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}')" -- "$1"))
}
_ip_addresses () 
{ 
    local n;
    case $1 in 
        -a)
            n='6\?'
        ;;
        -6)
            n='6'
        ;;
    esac;
    local PATH=$PATH:/sbin;
    local addrs=$({ LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null |
        command sed -e 's/[[:space:]]addr:/ /' -ne             "s|.*inet${n}[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p");
    COMPREPLY+=($(compgen -W "$addrs" -- "$cur"))
}
_kernel_versions () 
{ 
    COMPREPLY=($(compgen -W '$(command ls /lib/modules)' -- "$cur"))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    _known_hosts_real $options -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix OIFS=$IFS;
    local cur user suffix aliases i host ipv4 ipv6;
    local -a kh tmpkh khd config;
    local OPTIND=1;
    while getopts "ac46F:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
            4)
                ipv4=1
            ;;
            6)
                ipv6=1
            ;;
        esac;
    done;
    [[ $# -lt $OPTIND ]] && echo "bash_completion: $FUNCNAME: missing mandatory argument CWORD" 1>&2;
    cur=${!OPTIND};
    (( OPTIND += 1 ));
    [[ $# -ge $OPTIND ]] && echo "bash_completion: $FUNCNAME($*): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done) 1>&2;
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    for i in "${config[@]}";
    do
        _included_ssh_config_files "$i";
    done;
    if [[ ${#config[@]} -gt 0 ]]; then
        local IFS='
' j;
        tmpkh=($(awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u));
        IFS=$OIFS;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ -z $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        if [[ ${#kh[@]} -gt 0 ]]; then
            for i in "${kh[@]}";
            do
                while read -ra tmpkh; do
                    set -- "${tmpkh[@]}";
                    [[ $1 == [\|\#]* ]] && continue;
                    [[ $1 == @* ]] && shift;
                    local IFS=,;
                    for host in $1;
                    do
                        [[ $host == *[*?]* ]] && continue;
                        host="${host#[}";
                        host="${host%]?(:+([0-9]))}";
                        COMPREPLY+=($host);
                    done;
                    IFS=$OIFS;
                done < "$i";
            done;
            COMPREPLY=($(compgen -W '${COMPREPLY[@]}' -- "$cur"));
        fi;
        if [[ ${#khd[@]} -gt 0 ]]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$cur*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$(command sed -ne 's/^[[:blank:]]*[Hh][Oo][Ss][Tt][[:blank:]]\{1,\}\([^#*?%]*\)\(#.*\)\{0,1\}$/\1/p' "${config[@]}");
        COMPREPLY+=($(compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur"));
    fi;
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_AVAHI:-} ]] && type avahi-browse &> /dev/null; then
        COMPREPLY+=($(compgen -P "$prefix$user" -S "$suffix" -W             "$(avahi-browse -cpr _workstation._tcp 2>/dev/null |                awk -F';' '/^=/ { print $7 }' | sort -u)" -- "$cur"));
    fi;
    COMPREPLY+=($(compgen -W         "$(ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }')"         -- "$cur"));
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($(compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur"));
    fi;
    if [[ -n $ipv4 ]]; then
        COMPREPLY=("${COMPREPLY[@]/*:*$suffix/}");
    fi;
    if [[ -n $ipv6 ]]; then
        COMPREPLY=("${COMPREPLY[@]/+([0-9]).+([0-9]).+([0-9]).+([0-9])$suffix/}");
    fi;
    if [[ -n $ipv4 || -n $ipv6 ]]; then
        for i in "${!COMPREPLY[@]}";
        do
            [[ -n ${COMPREPLY[i]} ]] || unset -v COMPREPLY[i];
        done;
    fi;
    __ltrim_colon_completions "$prefix$user$cur"
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return
        ;;
        --!(no-*)dir*)
            _filedir -d;
            return
        ;;
        --!(no-*)@(file|path)*)
            _filedir;
            return
        ;;
        --+([-a-z0-9_]))
            local argtype=$(LC_ALL=C $1 --help 2>&1 | command sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p");
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return
                ;;
                *file* | *path*)
                    _filedir;
                    return
                ;;
            esac
        ;;
    esac;
    $split && return;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "$(LC_ALL=C $1 --help 2>&1 |             while read -r line; do                 [[ $line =~ --[-A-Za-z0-9]+=? ]] &&                     printf '%s\n' ${BASH_REMATCH[0]}
            done)" -- "$cur"));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
    else
        if [[ "$1" == *@(rmdir|chroot) ]]; then
            _filedir -d;
        else
            [[ "$1" == *mkdir ]] && compopt -o nospace;
            _filedir;
        fi;
    fi
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(        { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | command sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
        ));
    COMPREPLY+=($({ arp -an || ip neigh show; } 2>/dev/null | command sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p"));
    COMPREPLY+=($(command sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null));
    COMPREPLY=($(compgen -W '${COMPREPLY[@]}' -- "$cur"));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($(compgen -W "$(command ls -RL $modpath 2>/dev/null |         command sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p')" -- "$cur"))
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$(getconf $var 2>/dev/null);
    printf %s ${n:-1}
}
_parse_help () 
{ 
    eval local cmd=$(quote "$1");
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$(dequote "$cmd")" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([[:blank:]])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+([,_-]+[A-Z0-9]+)?(\.\.+)?\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd=$(quote "$1");
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$(dequote "$cmd")" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i=1; i < ${#option}; i++ ))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pci_ids () 
{ 
    COMPREPLY+=($(compgen -W         "$(PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur"))
}
_pgids () 
{ 
    COMPREPLY=($(compgen -W '$(command ps axo pgid=)' -- "$cur"))
}
_pids () 
{ 
    COMPREPLY=($(compgen -W '$(command ps axo pid=)' -- "$cur"))
}
_pnames () 
{ 
    local -a procs;
    if [[ "$1" == -s ]]; then
        procs=($(command ps axo comm | command sed -e 1d));
    else
        local line i=-1 OIFS=$IFS;
        IFS='
';
        local -a psout=($(command ps axo command=));
        IFS=$OIFS;
        for line in "${psout[@]}";
        do
            if [[ $i -eq -1 ]]; then
                if [[ $line =~ ^(.*[[:space:]])COMMAND([[:space:]]|$) ]]; then
                    i=${#BASH_REMATCH[1]};
                else
                    break;
                fi;
            else
                line=${line:$i};
                line=${line%% *};
                procs+=($line);
            fi;
        done;
        if [[ $i -eq -1 ]]; then
            for line in "${psout[@]}";
            do
                if [[ $line =~ ^[[(](.+)[])]$ ]]; then
                    procs+=(${BASH_REMATCH[1]});
                else
                    line=${line%% *};
                    line=${line##@(*/|-)};
                    procs+=($line);
                fi;
            done;
        fi;
    fi;
    COMPREPLY=($(compgen -X "<defunct>" -W '${procs[@]}' -- "$cur" ))
}
_quote_readline_by_ref () 
{ 
    if [ -z "$1" ]; then
        printf -v $2 %s "$1";
    else
        if [[ $1 == \'* ]]; then
            printf -v $2 %s "${1:1}";
        else
            if [[ $1 == \~* ]]; then
                printf -v $2 \~%q "${1:1}";
            else
                printf -v $2 %q "$1";
            fi;
        fi;
    fi;
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_rl_enabled () 
{ 
    [[ "$(bind -v)" == *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    [[ $cword -gt 2 ]] && return;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($(compgen -W '`command sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur"));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local IFS=' 	
' reset=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($(printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions|README)));
    $reset;
    COMPREPLY+=($({ systemctl list-units --full --all ||                      systemctl list-unit-files; } 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }'));
    if [[ -x /sbin/upstart-udev-bridge ]]; then
        COMPREPLY+=($(initctl list 2>/dev/null | cut -d' ' -f1));
    fi;
    COMPREPLY=($(compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur"))
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($(compgen -P "$1" -A signal "SIG${cur#$1}"));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d);
    return 0
}
_terms () 
{ 
    COMPREPLY+=($(compgen -W "$({         command sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap;
        { toe -a || toe; } | awk '{ print $1 }';
        find /{etc,lib,usr/lib,usr/share}/terminfo/? -type f -maxdepth 1             | awk -F/ '{ print $NF }';
    } 2>/dev/null)" -- "$cur"))
}
_tilde () 
{ 
    local result=0;
    if [[ $1 == \~* && $1 != */* ]]; then
        COMPREPLY=($(compgen -P '~' -u -- "${1#\~}"));
        result=${#COMPREPLY[@]};
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($(compgen -W '$(getent passwd | cut -d: -f3)' -- "$cur"));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($(compgen -W '$(perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"')' -- "$cur"));
        else
            COMPREPLY=($(compgen -W '$(cut -d: -f3 /etc/passwd)' -- "$cur"));
        fi;
    fi
}
_upvar () 
{ 
    echo "bash_completion: $FUNCNAME: deprecated function," "use _upvars instead" 1>&2;
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "bash_completion: $FUNCNAME: usage: $FUNCNAME" "[-v varname value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash_completion: $FUNCNAME:" "\`$1': missing number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo bash_completion: "$FUNCNAME: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo bash_completion: "$FUNCNAME: \`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash_completion: $FUNCNAME: $1:" "missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash_completion: $FUNCNAME: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($(compgen -W         "$(PATH="$PATH:/sbin" lsusb | awk '{print $6}')" -- "$cur"))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($(compgen -u -S @ -- "$cur"));
        compopt -o nospace;
    fi
}
_usergroup () 
{ 
    if [[ $cur == *\\\\* || $cur == *:*:* ]]; then
        return;
    else
        if [[ $cur == *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($(compgen -g -- "$mycur"));
            fi;
            COMPREPLY=($(compgen -P "$prefix" -W "${COMPREPLY[@]}"));
        else
            if [[ $cur == *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($(compgen -g -- "$mycur"));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($(compgen -u -- "$cur"));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$(uname -s);
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == $1 ]]
}
_variables () 
{ 
    if [[ $cur =~ ^(\$(\{[!#]?)?)([A-Za-z0-9_]*)$ ]]; then
        if [[ $cur == \${* ]]; then
            local arrs vars;
            vars=($(compgen -A variable -P ${BASH_REMATCH[1]} -S '}' -- ${BASH_REMATCH[3]})) && arrs=($(compgen -A arrayvar -P ${BASH_REMATCH[1]} -S '[' -- ${BASH_REMATCH[3]}));
            if [[ ${#vars[@]} -eq 1 && -n $arrs ]]; then
                compopt -o nospace;
                COMPREPLY+=(${arrs[*]});
            else
                COMPREPLY+=(${vars[*]});
            fi;
        else
            COMPREPLY+=($(compgen -A variable -P '$' -- "${BASH_REMATCH[3]}"));
        fi;
        return 0;
    else
        if [[ $cur =~ ^(\$\{[#!]?)([A-Za-z0-9_]*)\[([^]]*)$ ]]; then
            local IFS='
';
            COMPREPLY+=($(compgen -W '$(printf %s\\n "${!'${BASH_REMATCH[2]}'[@]}")'             -P "${BASH_REMATCH[1]}${BASH_REMATCH[2]}[" -S ']}' -- "${BASH_REMATCH[3]}"));
            if [[ ${BASH_REMATCH[3]} == [@*] ]]; then
                COMPREPLY+=("${BASH_REMATCH[1]}${BASH_REMATCH[2]}[${BASH_REMATCH[3]}]}");
            fi;
            __ltrim_colon_completions "$cur";
            return 0;
        else
            if [[ $cur =~ ^\$\{[#!]?[A-Za-z0-9_]*\[.*\]$ ]]; then
                COMPREPLY+=("$cur}");
                __ltrim_colon_completions "$cur";
                return 0;
            else
                case $prev in 
                    TZ)
                        cur=/usr/share/zoneinfo/$cur;
                        _filedir;
                        for i in "${!COMPREPLY[@]}";
                        do
                            if [[ ${COMPREPLY[i]} == *.tab ]]; then
                                unset 'COMPREPLY[i]';
                                continue;
                            else
                                if [[ -d ${COMPREPLY[i]} ]]; then
                                    COMPREPLY[i]+=/;
                                    compopt -o nospace;
                                fi;
                            fi;
                            COMPREPLY[i]=${COMPREPLY[i]#/usr/share/zoneinfo/};
                        done;
                        return 0
                    ;;
                    TERM)
                        _terms;
                        return 0
                    ;;
                    LANG | LC_*)
                        COMPREPLY=($(compgen -W '$(locale -a 2>/dev/null)'                     -- "$cur" ));
                        return 0
                    ;;
                esac;
            fi;
        fi;
    fi;
    return 1
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || { 
        __load_completion "$srcfile"
    };
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=/etc/xinetd.d;
    if [[ -d $xinetddir ]]; then
        local IFS=' 	
' reset=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($(printf '%s\n' $xinetddir/!($_backup_glob)));
        $reset;
        COMPREPLY+=($(compgen -W '${svcs[@]#$xinetddir/}' -- "$cur"));
    fi
}
command_not_found_handle () 
{ 
    if [ -x /usr/lib/command-not-found ]; then
        /usr/lib/command-not-found -- "$1";
        return $?;
    else
        if [ -x /usr/share/command-not-found/command-not-found ]; then
            /usr/share/command-not-found/command-not-found -- "$1";
            return $?;
        else
            printf "%s: command not found\n" "$1" 1>&2;
            return 127;
        fi;
    fi
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
gawklibpath_append () 
{ 
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$AWKLIBPATH:$*"
}
gawklibpath_default () 
{ 
    unset AWKLIBPATH;
    export AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`
}
gawklibpath_prepend () 
{ 
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$*:$AWKLIBPATH"
}
gawkpath_append () 
{ 
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$AWKPATH:$*"
}
gawkpath_default () 
{ 
    unset AWKPATH;
    export AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`
}
gawkpath_prepend () 
{ 
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$*:$AWKPATH"
}
nvm () 
{ 
    if [ $# -lt 1 ]; then
        nvm --help;
        return;
    fi;
    local DEFAULT_IFS;
    DEFAULT_IFS=" $(nvm_echo t | command tr t \\t)
";
    if [ "${-#*e}" != "$-" ]; then
        set +e;
        local EXIT_CODE;
        IFS="${DEFAULT_IFS}" nvm "$@";
        EXIT_CODE=$?;
        set -e;
        return $EXIT_CODE;
    else
        if [ "${IFS}" != "${DEFAULT_IFS}" ]; then
            IFS="${DEFAULT_IFS}" nvm "$@";
            return $?;
        fi;
    fi;
    local i;
    for i in "$@";
    do
        case $i in 
            --)
                break
            ;;
            '-h' | 'help' | '--help')
                NVM_NO_COLORS="";
                for j in "$@";
                do
                    if [ "${j}" = '--no-colors' ]; then
                        NVM_NO_COLORS="${j}";
                        break;
                    fi;
                done;
                local INITIAL_COLOR_INFO;
                local RED_INFO;
                local GREEN_INFO;
                local BLUE_INFO;
                local CYAN_INFO;
                local MAGENTA_INFO;
                local YELLOW_INFO;
                local BLACK_INFO;
                local GREY_WHITE_INFO;
                if [ -z "${NVM_NO_COLORS-}" ] && nvm_has_colors; then
                    INITIAL_COLOR_INFO='\033[0;32m g\033[0m \033[0;34m b\033[0m \033[0;33m y\033[0m \033[0;31m r\033[0m \033[0;37m e\033[0m';
                    RED_INFO='\033[0;31m r\033[0m/\033[1;31mR\033[0m = \033[0;31mred\033[0m / \033[1;31mbold red\033[0m';
                    GREEN_INFO='\033[0;32m g\033[0m/\033[1;32mG\033[0m = \033[0;32mgreen\033[0m / \033[1;32mbold green\033[0m';
                    BLUE_INFO='\033[0;34m b\033[0m/\033[1;34mB\033[0m = \033[0;34mblue\033[0m / \033[1;34mbold blue\033[0m';
                    CYAN_INFO='\033[0;36m c\033[0m/\033[1;36mC\033[0m = \033[0;36mcyan\033[0m / \033[1;36mbold cyan\033[0m';
                    MAGENTA_INFO='\033[0;35m m\033[0m/\033[1;35mM\033[0m = \033[0;35mmagenta\033[0m / \033[1;35mbold magenta\033[0m';
                    YELLOW_INFO='\033[0;33m y\033[0m/\033[1;33mY\033[0m = \033[0;33myellow\033[0m / \033[1;33mbold yellow\033[0m';
                    BLACK_INFO='\033[0;30m k\033[0m/\033[1;30mK\033[0m = \033[0;30mblack\033[0m / \033[1;30mbold black\033[0m';
                    GREY_WHITE_INFO='\033[0;37m e\033[0m/\033[1;37mW\033[0m = \033[0;37mlight grey\033[0m / \033[1;37mwhite\033[0m';
                else
                    INITIAL_COLOR_INFO='gbYre';
                    RED_INFO='r/R = red / bold red';
                    GREEN_INFO='g/G = green / bold green';
                    BLUE_INFO='b/B = blue / bold blue';
                    CYAN_INFO='c/C = cyan / bold cyan';
                    MAGENTA_INFO='m/M = magenta / bold magenta';
                    YELLOW_INFO='y/Y = yellow / bold yellow';
                    BLACK_INFO='k/K = black / bold black';
                    GREY_WHITE_INFO='e/W = light grey / white';
                fi;
                local NVM_IOJS_PREFIX;
                NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
                local NVM_NODE_PREFIX;
                NVM_NODE_PREFIX="$(nvm_node_prefix)";
                NVM_VERSION="$(nvm --version)";
                nvm_echo;
                nvm_echo "Node Version Manager (v${NVM_VERSION})";
                nvm_echo;
                nvm_echo 'Note: <version> refers to any version-like string nvm understands. This includes:';
                nvm_echo '  - full or partial version numbers, starting with an optional "v" (0.10, v0.1.2, v1)';
                nvm_echo "  - default (built-in) aliases: ${NVM_NODE_PREFIX}, stable, unstable, ${NVM_IOJS_PREFIX}, system";
                nvm_echo '  - custom aliases you define with `nvm alias foo`';
                nvm_echo;
                nvm_echo ' Any options that produce colorized output should respect the `--no-colors` option.';
                nvm_echo;
                nvm_echo 'Usage:';
                nvm_echo '  nvm --help                                  Show this message';
                nvm_echo '    --no-colors                               Suppress colored output';
                nvm_echo '  nvm --version                               Print out the installed version of nvm';
                nvm_echo '  nvm install [<version>]                     Download and install a <version>. Uses .nvmrc if available and version is omitted.';
                nvm_echo '   The following optional arguments, if provided, must appear directly after `nvm install`:';
                nvm_echo '    -s                                        Skip binary download, install from source only.';
                nvm_echo '    -b                                        Skip source download, install from binary only.';
                nvm_echo '    --reinstall-packages-from=<version>       When installing, reinstall packages installed in <node|iojs|node version number>';
                nvm_echo '    --lts                                     When installing, only select from LTS (long-term support) versions';
                nvm_echo '    --lts=<LTS name>                          When installing, only select from versions for a specific LTS line';
                nvm_echo '    --skip-default-packages                   When installing, skip the default-packages file if it exists';
                nvm_echo '    --latest-npm                              After installing, attempt to upgrade to the latest working npm on the given node version';
                nvm_echo '    --no-progress                             Disable the progress bar on any downloads';
                nvm_echo '    --alias=<name>                            After installing, set the alias specified to the version specified. (same as: nvm alias <name> <version>)';
                nvm_echo '    --default                                 After installing, set default alias to the version specified. (same as: nvm alias default <version>)';
                nvm_echo '  nvm uninstall <version>                     Uninstall a version';
                nvm_echo '  nvm uninstall --lts                         Uninstall using automatic LTS (long-term support) alias `lts/*`, if available.';
                nvm_echo '  nvm uninstall --lts=<LTS name>              Uninstall using automatic alias for provided LTS line, if available.';
                nvm_echo '  nvm use [<version>]                         Modify PATH to use <version>. Uses .nvmrc if available and version is omitted.';
                nvm_echo '   The following optional arguments, if provided, must appear directly after `nvm use`:';
                nvm_echo '    --silent                                  Silences stdout/stderr output';
                nvm_echo '    --lts                                     Uses automatic LTS (long-term support) alias `lts/*`, if available.';
                nvm_echo '    --lts=<LTS name>                          Uses automatic alias for provided LTS line, if available.';
                nvm_echo '  nvm exec [<version>] [<command>]            Run <command> on <version>. Uses .nvmrc if available and version is omitted.';
                nvm_echo '   The following optional arguments, if provided, must appear directly after `nvm exec`:';
                nvm_echo '    --silent                                  Silences stdout/stderr output';
                nvm_echo '    --lts                                     Uses automatic LTS (long-term support) alias `lts/*`, if available.';
                nvm_echo '    --lts=<LTS name>                          Uses automatic alias for provided LTS line, if available.';
                nvm_echo '  nvm run [<version>] [<args>]                Run `node` on <version> with <args> as arguments. Uses .nvmrc if available and version is omitted.';
                nvm_echo '   The following optional arguments, if provided, must appear directly after `nvm run`:';
                nvm_echo '    --silent                                  Silences stdout/stderr output';
                nvm_echo '    --lts                                     Uses automatic LTS (long-term support) alias `lts/*`, if available.';
                nvm_echo '    --lts=<LTS name>                          Uses automatic alias for provided LTS line, if available.';
                nvm_echo '  nvm current                                 Display currently activated version of Node';
                nvm_echo '  nvm ls [<version>]                          List installed versions, matching a given <version> if provided';
                nvm_echo '    --no-colors                               Suppress colored output';
                nvm_echo '    --no-alias                                Suppress `nvm alias` output';
                nvm_echo '  nvm ls-remote [<version>]                   List remote versions available for install, matching a given <version> if provided';
                nvm_echo '    --lts                                     When listing, only show LTS (long-term support) versions';
                nvm_echo '    --lts=<LTS name>                          When listing, only show versions for a specific LTS line';
                nvm_echo '    --no-colors                               Suppress colored output';
                nvm_echo '  nvm version <version>                       Resolve the given description to a single local version';
                nvm_echo '  nvm version-remote <version>                Resolve the given description to a single remote version';
                nvm_echo '    --lts                                     When listing, only select from LTS (long-term support) versions';
                nvm_echo '    --lts=<LTS name>                          When listing, only select from versions for a specific LTS line';
                nvm_echo '  nvm deactivate                              Undo effects of `nvm` on current shell';
                nvm_echo '    --silent                                  Silences stdout/stderr output';
                nvm_echo '  nvm alias [<pattern>]                       Show all aliases beginning with <pattern>';
                nvm_echo '    --no-colors                               Suppress colored output';
                nvm_echo '  nvm alias <name> <version>                  Set an alias named <name> pointing to <version>';
                nvm_echo '  nvm unalias <name>                          Deletes the alias named <name>';
                nvm_echo '  nvm install-latest-npm                      Attempt to upgrade to the latest working `npm` on the current node version';
                nvm_echo '  nvm reinstall-packages <version>            Reinstall global `npm` packages contained in <version> to current version';
                nvm_echo '  nvm unload                                  Unload `nvm` from shell';
                nvm_echo '  nvm which [current | <version>]             Display path to installed node version. Uses .nvmrc if available and version is omitted.';
                nvm_echo '    --silent                                  Silences stdout/stderr output when a version is omitted';
                nvm_echo '  nvm cache dir                               Display path to the cache directory for nvm';
                nvm_echo '  nvm cache clear                             Empty cache directory for nvm';
                nvm_echo '  nvm set-colors [<color codes>]              Set five text colors using format "yMeBg". Available when supported.';
                nvm_echo '                                               Initial colors are:';
                nvm_echo_with_colors "                                                  ${INITIAL_COLOR_INFO}";
                nvm_echo '                                               Color codes:';
                nvm_echo_with_colors "                                                ${RED_INFO}";
                nvm_echo_with_colors "                                                ${GREEN_INFO}";
                nvm_echo_with_colors "                                                ${BLUE_INFO}";
                nvm_echo_with_colors "                                                ${CYAN_INFO}";
                nvm_echo_with_colors "                                                ${MAGENTA_INFO}";
                nvm_echo_with_colors "                                                ${YELLOW_INFO}";
                nvm_echo_with_colors "                                                ${BLACK_INFO}";
                nvm_echo_with_colors "                                                ${GREY_WHITE_INFO}";
                nvm_echo;
                nvm_echo 'Example:';
                nvm_echo '  nvm install 8.0.0                     Install a specific version number';
                nvm_echo '  nvm use 8.0                           Use the latest available 8.0.x release';
                nvm_echo '  nvm run 6.10.3 app.js                 Run app.js using node 6.10.3';
                nvm_echo '  nvm exec 4.8.3 node app.js            Run `node app.js` with the PATH pointing to node 4.8.3';
                nvm_echo '  nvm alias default 8.1.0               Set default node version on a shell';
                nvm_echo '  nvm alias default node                Always default to the latest available node version on a shell';
                nvm_echo;
                nvm_echo '  nvm install node                      Install the latest available version';
                nvm_echo '  nvm use node                          Use the latest version';
                nvm_echo '  nvm install --lts                     Install the latest LTS version';
                nvm_echo '  nvm use --lts                         Use the latest LTS version';
                nvm_echo;
                nvm_echo '  nvm set-colors cgYmW                  Set text colors to cyan, green, bold yellow, magenta, and white';
                nvm_echo;
                nvm_echo 'Note:';
                nvm_echo '  to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`)';
                nvm_echo;
                return 0
            ;;
        esac;
    done;
    local COMMAND;
    COMMAND="${1-}";
    shift;
    local VERSION;
    local ADDITIONAL_PARAMETERS;
    case $COMMAND in 
        "cache")
            case "${1-}" in 
                dir)
                    nvm_cache_dir
                ;;
                clear)
                    local DIR;
                    DIR="$(nvm_cache_dir)";
                    if command rm -rf "${DIR}" && command mkdir -p "${DIR}"; then
                        nvm_echo 'nvm cache cleared.';
                    else
                        nvm_err "Unable to clear nvm cache: ${DIR}";
                        return 1;
                    fi
                ;;
                *)
                    nvm --help 1>&2;
                    return 127
                ;;
            esac
        ;;
        "debug")
            local OS_VERSION;
            nvm_is_zsh && setopt local_options shwordsplit;
            nvm_err "nvm --version: v$(nvm --version)";
            if [ -n "${TERM_PROGRAM-}" ]; then
                nvm_err "\$TERM_PROGRAM: ${TERM_PROGRAM}";
            fi;
            nvm_err "\$SHELL: ${SHELL}";
            nvm_err "\$SHLVL: ${SHLVL-}";
            nvm_err "whoami: '$(whoami)'";
            nvm_err "\${HOME}: ${HOME}";
            nvm_err "\${NVM_DIR}: '$(nvm_sanitize_path "${NVM_DIR}")'";
            nvm_err "\${PATH}: $(nvm_sanitize_path "${PATH}")";
            nvm_err "\$PREFIX: '$(nvm_sanitize_path "${PREFIX}")'";
            nvm_err "\${NPM_CONFIG_PREFIX}: '$(nvm_sanitize_path "${NPM_CONFIG_PREFIX}")'";
            nvm_err "\$NVM_NODEJS_ORG_MIRROR: '${NVM_NODEJS_ORG_MIRROR}'";
            nvm_err "\$NVM_IOJS_ORG_MIRROR: '${NVM_IOJS_ORG_MIRROR}'";
            nvm_err "shell version: '$(${SHELL} --version | command head -n 1)'";
            nvm_err "uname -a: '$(command uname -a | command awk '{$2=""; print}' | command xargs)'";
            nvm_err "checksum binary: '$(nvm_get_checksum_binary 2>/dev/null)'";
            if [ "$(nvm_get_os)" = "darwin" ] && nvm_has sw_vers; then
                OS_VERSION="$(sw_vers | command awk '{print $2}' | command xargs)";
            else
                if [ -r "/etc/issue" ]; then
                    OS_VERSION="$(command head -n 1 /etc/issue | command sed 's/\\.//g')";
                    if [ -z "${OS_VERSION}" ] && [ -r "/etc/os-release" ]; then
                        OS_VERSION="$(. /etc/os-release && echo "${NAME}" "${VERSION}")";
                    fi;
                fi;
            fi;
            if [ -n "${OS_VERSION}" ]; then
                nvm_err "OS version: ${OS_VERSION}";
            fi;
            if nvm_has "curl"; then
                nvm_err "curl: $(nvm_command_info curl), $(command curl -V | command head -n 1)";
            else
                nvm_err "curl: not found";
            fi;
            if nvm_has "wget"; then
                nvm_err "wget: $(nvm_command_info wget), $(command wget -V | command head -n 1)";
            else
                nvm_err "wget: not found";
            fi;
            local TEST_TOOLS ADD_TEST_TOOLS;
            TEST_TOOLS="git grep awk";
            ADD_TEST_TOOLS="sed cut basename rm mkdir xargs";
            if [ "darwin" != "$(nvm_get_os)" ] && [ "freebsd" != "$(nvm_get_os)" ]; then
                TEST_TOOLS="${TEST_TOOLS} ${ADD_TEST_TOOLS}";
            else
                for tool in ${ADD_TEST_TOOLS};
                do
                    if nvm_has "${tool}"; then
                        nvm_err "${tool}: $(nvm_command_info "${tool}")";
                    else
                        nvm_err "${tool}: not found";
                    fi;
                done;
            fi;
            for tool in ${TEST_TOOLS};
            do
                local NVM_TOOL_VERSION;
                if nvm_has "${tool}"; then
                    if command ls -l "$(nvm_command_info "${tool}" | command awk '{print $1}')" | command grep -q busybox; then
                        NVM_TOOL_VERSION="$(command "${tool}" --help 2>&1 | command head -n 1)";
                    else
                        NVM_TOOL_VERSION="$(command "${tool}" --version 2>&1 | command head -n 1)";
                    fi;
                    nvm_err "${tool}: $(nvm_command_info "${tool}"), ${NVM_TOOL_VERSION}";
                else
                    nvm_err "${tool}: not found";
                fi;
                unset NVM_TOOL_VERSION;
            done;
            unset TEST_TOOLS ADD_TEST_TOOLS;
            local NVM_DEBUG_OUTPUT;
            for NVM_DEBUG_COMMAND in 'nvm current' 'which node' 'which iojs' 'which npm' 'npm config get prefix' 'npm root -g';
            do
                NVM_DEBUG_OUTPUT="$(${NVM_DEBUG_COMMAND} 2>&1)";
                nvm_err "${NVM_DEBUG_COMMAND}: $(nvm_sanitize_path "${NVM_DEBUG_OUTPUT}")";
            done;
            return 42
        ;;
        "install" | "i")
            local version_not_provided;
            version_not_provided=0;
            local NVM_OS;
            NVM_OS="$(nvm_get_os)";
            if ! nvm_has "curl" && ! nvm_has "wget"; then
                nvm_err 'nvm needs curl or wget to proceed.';
                return 1;
            fi;
            if [ $# -lt 1 ]; then
                version_not_provided=1;
            fi;
            local nobinary;
            local nosource;
            local noprogress;
            nobinary=0;
            noprogress=0;
            nosource=0;
            local LTS;
            local ALIAS;
            local NVM_UPGRADE_NPM;
            NVM_UPGRADE_NPM=0;
            local PROVIDED_REINSTALL_PACKAGES_FROM;
            local REINSTALL_PACKAGES_FROM;
            local SKIP_DEFAULT_PACKAGES;
            local DEFAULT_PACKAGES;
            while [ $# -ne 0 ]; do
                case "$1" in 
                    ---*)
                        nvm_err 'arguments with `---` are not supported - this is likely a typo';
                        return 55
                    ;;
                    -s)
                        shift;
                        nobinary=1;
                        if [ $nosource -eq 1 ]; then
                            nvm err '-s and -b cannot be set together since they would skip install from both binary and source';
                            return 6;
                        fi
                    ;;
                    -b)
                        shift;
                        nosource=1;
                        if [ $nobinary -eq 1 ]; then
                            nvm err '-s and -b cannot be set together since they would skip install from both binary and source';
                            return 6;
                        fi
                    ;;
                    -j)
                        shift;
                        nvm_get_make_jobs "$1";
                        shift
                    ;;
                    --no-progress)
                        noprogress=1;
                        shift
                    ;;
                    --lts)
                        LTS='*';
                        shift
                    ;;
                    --lts=*)
                        LTS="${1##--lts=}";
                        shift
                    ;;
                    --latest-npm)
                        NVM_UPGRADE_NPM=1;
                        shift
                    ;;
                    --default)
                        if [ -n "${ALIAS-}" ]; then
                            nvm_err '--default and --alias are mutually exclusive, and may not be provided more than once';
                            return 6;
                        fi;
                        ALIAS='default';
                        shift
                    ;;
                    --alias=*)
                        if [ -n "${ALIAS-}" ]; then
                            nvm_err '--default and --alias are mutually exclusive, and may not be provided more than once';
                            return 6;
                        fi;
                        ALIAS="${1##--alias=}";
                        shift
                    ;;
                    --reinstall-packages-from=*)
                        if [ -n "${PROVIDED_REINSTALL_PACKAGES_FROM-}" ]; then
                            nvm_err '--reinstall-packages-from may not be provided more than once';
                            return 6;
                        fi;
                        PROVIDED_REINSTALL_PACKAGES_FROM="$(nvm_echo "$1" | command cut -c 27-)";
                        if [ -z "${PROVIDED_REINSTALL_PACKAGES_FROM}" ]; then
                            nvm_err 'If --reinstall-packages-from is provided, it must point to an installed version of node.';
                            return 6;
                        fi;
                        REINSTALL_PACKAGES_FROM="$(nvm_version "${PROVIDED_REINSTALL_PACKAGES_FROM}")" || :;
                        shift
                    ;;
                    --copy-packages-from=*)
                        if [ -n "${PROVIDED_REINSTALL_PACKAGES_FROM-}" ]; then
                            nvm_err '--reinstall-packages-from may not be provided more than once, or combined with `--copy-packages-from`';
                            return 6;
                        fi;
                        PROVIDED_REINSTALL_PACKAGES_FROM="$(nvm_echo "$1" | command cut -c 22-)";
                        if [ -z "${PROVIDED_REINSTALL_PACKAGES_FROM}" ]; then
                            nvm_err 'If --copy-packages-from is provided, it must point to an installed version of node.';
                            return 6;
                        fi;
                        REINSTALL_PACKAGES_FROM="$(nvm_version "${PROVIDED_REINSTALL_PACKAGES_FROM}")" || :;
                        shift
                    ;;
                    --reinstall-packages-from | --copy-packages-from)
                        nvm_err "If ${1} is provided, it must point to an installed version of node using \`=\`.";
                        return 6
                    ;;
                    --skip-default-packages)
                        SKIP_DEFAULT_PACKAGES=true;
                        shift
                    ;;
                    *)
                        break
                    ;;
                esac;
            done;
            local provided_version;
            provided_version="${1-}";
            if [ -z "${provided_version}" ]; then
                if [ "_${LTS-}" = '_*' ]; then
                    nvm_echo 'Installing latest LTS version.';
                    if [ $# -gt 0 ]; then
                        shift;
                    fi;
                else
                    if [ "_${LTS-}" != '_' ]; then
                        nvm_echo "Installing with latest version of LTS line: ${LTS}";
                        if [ $# -gt 0 ]; then
                            shift;
                        fi;
                    else
                        nvm_rc_version;
                        if [ $version_not_provided -eq 1 ] && [ -z "${NVM_RC_VERSION}" ]; then
                            unset NVM_RC_VERSION;
                            nvm --help 1>&2;
                            return 127;
                        fi;
                        provided_version="${NVM_RC_VERSION}";
                        unset NVM_RC_VERSION;
                    fi;
                fi;
            else
                if [ $# -gt 0 ]; then
                    shift;
                fi;
            fi;
            case "${provided_version}" in 
                'lts/*')
                    LTS='*';
                    provided_version=''
                ;;
                lts/*)
                    LTS="${provided_version##lts/}";
                    provided_version=''
                ;;
            esac;
            VERSION="$(NVM_VERSION_ONLY=true NVM_LTS="${LTS-}" nvm_remote_version "${provided_version}")";
            if [ "${VERSION}" = 'N/A' ]; then
                local LTS_MSG;
                local REMOTE_CMD;
                if [ "${LTS-}" = '*' ]; then
                    LTS_MSG='(with LTS filter) ';
                    REMOTE_CMD='nvm ls-remote --lts';
                else
                    if [ -n "${LTS-}" ]; then
                        LTS_MSG="(with LTS filter '${LTS}') ";
                        REMOTE_CMD="nvm ls-remote --lts=${LTS}";
                    else
                        REMOTE_CMD='nvm ls-remote';
                    fi;
                fi;
                nvm_err "Version '${provided_version}' ${LTS_MSG-}not found - try \`${REMOTE_CMD}\` to browse available versions.";
                return 3;
            fi;
            ADDITIONAL_PARAMETERS='';
            while [ $# -ne 0 ]; do
                case "$1" in 
                    --reinstall-packages-from=*)
                        if [ -n "${PROVIDED_REINSTALL_PACKAGES_FROM-}" ]; then
                            nvm_err '--reinstall-packages-from may not be provided more than once';
                            return 6;
                        fi;
                        PROVIDED_REINSTALL_PACKAGES_FROM="$(nvm_echo "$1" | command cut -c 27-)";
                        if [ -z "${PROVIDED_REINSTALL_PACKAGES_FROM}" ]; then
                            nvm_err 'If --reinstall-packages-from is provided, it must point to an installed version of node.';
                            return 6;
                        fi;
                        REINSTALL_PACKAGES_FROM="$(nvm_version "${PROVIDED_REINSTALL_PACKAGES_FROM}")" || :
                    ;;
                    --copy-packages-from=*)
                        if [ -n "${PROVIDED_REINSTALL_PACKAGES_FROM-}" ]; then
                            nvm_err '--reinstall-packages-from may not be provided more than once, or combined with `--copy-packages-from`';
                            return 6;
                        fi;
                        PROVIDED_REINSTALL_PACKAGES_FROM="$(nvm_echo "$1" | command cut -c 22-)";
                        if [ -z "${PROVIDED_REINSTALL_PACKAGES_FROM}" ]; then
                            nvm_err 'If --copy-packages-from is provided, it must point to an installed version of node.';
                            return 6;
                        fi;
                        REINSTALL_PACKAGES_FROM="$(nvm_version "${PROVIDED_REINSTALL_PACKAGES_FROM}")" || :
                    ;;
                    --reinstall-packages-from | --copy-packages-from)
                        nvm_err "If ${1} is provided, it must point to an installed version of node using \`=\`.";
                        return 6
                    ;;
                    --skip-default-packages)
                        SKIP_DEFAULT_PACKAGES=true
                    ;;
                    *)
                        ADDITIONAL_PARAMETERS="${ADDITIONAL_PARAMETERS} $1"
                    ;;
                esac;
                shift;
            done;
            if [ -z "${SKIP_DEFAULT_PACKAGES-}" ]; then
                DEFAULT_PACKAGES="$(nvm_get_default_packages)";
                EXIT_CODE=$?;
                if [ $EXIT_CODE -ne 0 ]; then
                    return $EXIT_CODE;
                fi;
            fi;
            if [ -n "${PROVIDED_REINSTALL_PACKAGES_FROM-}" ] && [ "$(nvm_ensure_version_prefix "${PROVIDED_REINSTALL_PACKAGES_FROM}")" = "${VERSION}" ]; then
                nvm_err "You can't reinstall global packages from the same version of node you're installing.";
                return 4;
            else
                if [ "${REINSTALL_PACKAGES_FROM-}" = 'N/A' ]; then
                    nvm_err "If --reinstall-packages-from is provided, it must point to an installed version of node.";
                    return 5;
                fi;
            fi;
            local FLAVOR;
            if nvm_is_iojs_version "${VERSION}"; then
                FLAVOR="$(nvm_iojs_prefix)";
            else
                FLAVOR="$(nvm_node_prefix)";
            fi;
            if nvm_is_version_installed "${VERSION}"; then
                nvm_err "${VERSION} is already installed.";
                if nvm use "${VERSION}"; then
                    if [ "${NVM_UPGRADE_NPM}" = 1 ]; then
                        nvm install-latest-npm;
                    fi;
                    if [ -z "${SKIP_DEFAULT_PACKAGES-}" ] && [ -n "${DEFAULT_PACKAGES-}" ]; then
                        nvm_install_default_packages "${DEFAULT_PACKAGES}";
                    fi;
                    if [ -n "${REINSTALL_PACKAGES_FROM-}" ] && [ "_${REINSTALL_PACKAGES_FROM}" != "_N/A" ]; then
                        nvm reinstall-packages "${REINSTALL_PACKAGES_FROM}";
                    fi;
                fi;
                if [ -n "${LTS-}" ]; then
                    LTS="$(echo "${LTS}" | tr '[:upper:]' '[:lower:]')";
                    nvm_ensure_default_set "lts/${LTS}";
                else
                    nvm_ensure_default_set "${provided_version}";
                fi;
                if [ -n "${ALIAS-}" ]; then
                    nvm alias "${ALIAS}" "${provided_version}";
                fi;
                return $?;
            fi;
            local EXIT_CODE;
            EXIT_CODE=-1;
            if [ -n "${NVM_INSTALL_THIRD_PARTY_HOOK-}" ]; then
                nvm_err '** $NVM_INSTALL_THIRD_PARTY_HOOK env var set; dispatching to third-party installation method **';
                local NVM_METHOD_PREFERENCE;
                NVM_METHOD_PREFERENCE='binary';
                if [ $nobinary -eq 1 ]; then
                    NVM_METHOD_PREFERENCE='source';
                fi;
                local VERSION_PATH;
                VERSION_PATH="$(nvm_version_path "${VERSION}")";
                "${NVM_INSTALL_THIRD_PARTY_HOOK}" "${VERSION}" "${FLAVOR}" std "${NVM_METHOD_PREFERENCE}" "${VERSION_PATH}" || { 
                    EXIT_CODE=$?;
                    nvm_err '*** Third-party $NVM_INSTALL_THIRD_PARTY_HOOK env var failed to install! ***';
                    return $EXIT_CODE
                };
                if ! nvm_is_version_installed "${VERSION}"; then
                    nvm_err '*** Third-party $NVM_INSTALL_THIRD_PARTY_HOOK env var claimed to succeed, but failed to install! ***';
                    return 33;
                fi;
                EXIT_CODE=0;
            else
                if [ "_${NVM_OS}" = "_freebsd" ]; then
                    nobinary=1;
                    nvm_err "Currently, there is no binary for FreeBSD";
                else
                    if [ "_${NVM_OS}" = "_sunos" ]; then
                        if ! nvm_has_solaris_binary "${VERSION}"; then
                            nobinary=1;
                            nvm_err "Currently, there is no binary of version ${VERSION} for SunOS";
                        fi;
                    fi;
                fi;
                if [ $nobinary -ne 1 ] && nvm_binary_available "${VERSION}"; then
                    NVM_NO_PROGRESS="${NVM_NO_PROGRESS:-${noprogress}}" nvm_install_binary "${FLAVOR}" std "${VERSION}" "${nosource}";
                    EXIT_CODE=$?;
                fi;
                if [ $EXIT_CODE -ne 0 ]; then
                    if [ -z "${NVM_MAKE_JOBS-}" ]; then
                        nvm_get_make_jobs;
                    fi;
                    NVM_NO_PROGRESS="${NVM_NO_PROGRESS:-${noprogress}}" nvm_install_source "${FLAVOR}" std "${VERSION}" "${NVM_MAKE_JOBS}" "${ADDITIONAL_PARAMETERS}";
                    EXIT_CODE=$?;
                fi;
            fi;
            if [ $EXIT_CODE -eq 0 ] && nvm_use_if_needed "${VERSION}" && nvm_install_npm_if_needed "${VERSION}"; then
                if [ -n "${LTS-}" ]; then
                    nvm_ensure_default_set "lts/${LTS}";
                else
                    nvm_ensure_default_set "${provided_version}";
                fi;
                if [ "${NVM_UPGRADE_NPM}" = 1 ]; then
                    nvm install-latest-npm;
                    EXIT_CODE=$?;
                fi;
                if [ -z "${SKIP_DEFAULT_PACKAGES-}" ] && [ -n "${DEFAULT_PACKAGES-}" ]; then
                    nvm_install_default_packages "${DEFAULT_PACKAGES}";
                fi;
                if [ -n "${REINSTALL_PACKAGES_FROM-}" ] && [ "_${REINSTALL_PACKAGES_FROM}" != "_N/A" ]; then
                    nvm reinstall-packages "${REINSTALL_PACKAGES_FROM}";
                    EXIT_CODE=$?;
                fi;
            else
                EXIT_CODE=$?;
            fi;
            return $EXIT_CODE
        ;;
        "uninstall")
            if [ $# -ne 1 ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            local PATTERN;
            PATTERN="${1-}";
            case "${PATTERN-}" in 
                --)

                ;;
                --lts | 'lts/*')
                    VERSION="$(nvm_match_version "lts/*")"
                ;;
                lts/*)
                    VERSION="$(nvm_match_version "lts/${PATTERN##lts/}")"
                ;;
                --lts=*)
                    VERSION="$(nvm_match_version "lts/${PATTERN##--lts=}")"
                ;;
                *)
                    VERSION="$(nvm_version "${PATTERN}")"
                ;;
            esac;
            if [ "_${VERSION}" = "_$(nvm_ls_current)" ]; then
                if nvm_is_iojs_version "${VERSION}"; then
                    nvm_err "nvm: Cannot uninstall currently-active io.js version, ${VERSION} (inferred from ${PATTERN}).";
                else
                    nvm_err "nvm: Cannot uninstall currently-active node version, ${VERSION} (inferred from ${PATTERN}).";
                fi;
                return 1;
            fi;
            if ! nvm_is_version_installed "${VERSION}"; then
                nvm_err "${VERSION} version is not installed...";
                return;
            fi;
            local SLUG_BINARY;
            local SLUG_SOURCE;
            if nvm_is_iojs_version "${VERSION}"; then
                SLUG_BINARY="$(nvm_get_download_slug iojs binary std "${VERSION}")";
                SLUG_SOURCE="$(nvm_get_download_slug iojs source std "${VERSION}")";
            else
                SLUG_BINARY="$(nvm_get_download_slug node binary std "${VERSION}")";
                SLUG_SOURCE="$(nvm_get_download_slug node source std "${VERSION}")";
            fi;
            local NVM_SUCCESS_MSG;
            if nvm_is_iojs_version "${VERSION}"; then
                NVM_SUCCESS_MSG="Uninstalled io.js $(nvm_strip_iojs_prefix "${VERSION}")";
            else
                NVM_SUCCESS_MSG="Uninstalled node ${VERSION}";
            fi;
            local VERSION_PATH;
            VERSION_PATH="$(nvm_version_path "${VERSION}")";
            if ! nvm_check_file_permissions "${VERSION_PATH}"; then
                nvm_err 'Cannot uninstall, incorrect permissions on installation folder.';
                nvm_err 'This is usually caused by running `npm install -g` as root. Run the following commands as root to fix the permissions and then try again.';
                nvm_err;
                nvm_err "  chown -R $(whoami) \"$(nvm_sanitize_path "${VERSION_PATH}")\"";
                nvm_err "  chmod -R u+w \"$(nvm_sanitize_path "${VERSION_PATH}")\"";
                return 1;
            fi;
            local CACHE_DIR;
            CACHE_DIR="$(nvm_cache_dir)";
            command rm -rf "${CACHE_DIR}/bin/${SLUG_BINARY}/files" "${CACHE_DIR}/src/${SLUG_SOURCE}/files" "${VERSION_PATH}" 2> /dev/null;
            nvm_echo "${NVM_SUCCESS_MSG}";
            for ALIAS in $(nvm_grep -l "${VERSION}" "$(nvm_alias_path)/*" 2>/dev/null);
            do
                nvm unalias "$(command basename "${ALIAS}")";
            done
        ;;
        "deactivate")
            local NVM_SILENT;
            while [ $# -ne 0 ]; do
                case "${1}" in 
                    --silent)
                        NVM_SILENT=1
                    ;;
                    --)

                    ;;
                esac;
                shift;
            done;
            local NEWPATH;
            NEWPATH="$(nvm_strip_path "${PATH}" "/bin")";
            if [ "_${PATH}" = "_${NEWPATH}" ]; then
                if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                    nvm_err "Could not find ${NVM_DIR}/*/bin in \${PATH}";
                fi;
            else
                export PATH="${NEWPATH}";
                hash -r;
                if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                    nvm_echo "${NVM_DIR}/*/bin removed from \${PATH}";
                fi;
            fi;
            if [ -n "${MANPATH-}" ]; then
                NEWPATH="$(nvm_strip_path "${MANPATH}" "/share/man")";
                if [ "_${MANPATH}" = "_${NEWPATH}" ]; then
                    if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                        nvm_err "Could not find ${NVM_DIR}/*/share/man in \${MANPATH}";
                    fi;
                else
                    export MANPATH="${NEWPATH}";
                    if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                        nvm_echo "${NVM_DIR}/*/share/man removed from \${MANPATH}";
                    fi;
                fi;
            fi;
            if [ -n "${NODE_PATH-}" ]; then
                NEWPATH="$(nvm_strip_path "${NODE_PATH}" "/lib/node_modules")";
                if [ "_${NODE_PATH}" != "_${NEWPATH}" ]; then
                    export NODE_PATH="${NEWPATH}";
                    if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                        nvm_echo "${NVM_DIR}/*/lib/node_modules removed from \${NODE_PATH}";
                    fi;
                fi;
            fi;
            unset NVM_BIN;
            unset NVM_INC
        ;;
        "use")
            local PROVIDED_VERSION;
            local NVM_SILENT;
            local NVM_SILENT_ARG;
            local NVM_DELETE_PREFIX;
            NVM_DELETE_PREFIX=0;
            local NVM_LTS;
            while [ $# -ne 0 ]; do
                case "$1" in 
                    --silent)
                        NVM_SILENT=1;
                        NVM_SILENT_ARG='--silent'
                    ;;
                    --delete-prefix)
                        NVM_DELETE_PREFIX=1
                    ;;
                    --)

                    ;;
                    --lts)
                        NVM_LTS='*'
                    ;;
                    --lts=*)
                        NVM_LTS="${1##--lts=}"
                    ;;
                    --*)

                    ;;
                    *)
                        if [ -n "${1-}" ]; then
                            PROVIDED_VERSION="$1";
                        fi
                    ;;
                esac;
                shift;
            done;
            if [ -n "${NVM_LTS-}" ]; then
                VERSION="$(nvm_match_version "lts/${NVM_LTS:-*}")";
            else
                if [ -z "${PROVIDED_VERSION-}" ]; then
                    NVM_SILENT="${NVM_SILENT:-0}" nvm_rc_version;
                    if [ -n "${NVM_RC_VERSION-}" ]; then
                        PROVIDED_VERSION="${NVM_RC_VERSION}";
                        VERSION="$(nvm_version "${PROVIDED_VERSION}")";
                    fi;
                    unset NVM_RC_VERSION;
                    if [ -z "${VERSION}" ]; then
                        nvm_err 'Please see `nvm --help` or https://github.com/nvm-sh/nvm#nvmrc for more information.';
                        return 127;
                    fi;
                else
                    VERSION="$(nvm_match_version "${PROVIDED_VERSION}")";
                fi;
            fi;
            if [ -z "${VERSION}" ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            if [ "_${VERSION}" = '_system' ]; then
                if nvm_has_system_node && nvm deactivate "${NVM_SILENT_ARG-}" > /dev/null 2>&1; then
                    if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                        nvm_echo "Now using system version of node: $(node -v 2>/dev/null)$(nvm_print_npm_version)";
                    fi;
                    return;
                else
                    if nvm_has_system_iojs && nvm deactivate "${NVM_SILENT_ARG-}" > /dev/null 2>&1; then
                        if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                            nvm_echo "Now using system version of io.js: $(iojs --version 2>/dev/null)$(nvm_print_npm_version)";
                        fi;
                        return;
                    else
                        if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                            nvm_err 'System version of node not found.';
                        fi;
                    fi;
                fi;
                return 127;
            else
                if [ "_${VERSION}" = "_∞" ]; then
                    if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                        nvm_err "The alias \"${PROVIDED_VERSION}\" leads to an infinite loop. Aborting.";
                    fi;
                    return 8;
                fi;
            fi;
            if [ "${VERSION}" = 'N/A' ]; then
                if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                    nvm_err "N/A: version \"${PROVIDED_VERSION} -> ${VERSION}\" is not yet installed.";
                    nvm_err "";
                    nvm_err "You need to run \"nvm install ${PROVIDED_VERSION}\" to install it before using it.";
                fi;
                return 3;
            else
                if ! nvm_ensure_version_installed "${VERSION}"; then
                    return $?;
                fi;
            fi;
            local NVM_VERSION_DIR;
            NVM_VERSION_DIR="$(nvm_version_path "${VERSION}")";
            PATH="$(nvm_change_path "${PATH}" "/bin" "${NVM_VERSION_DIR}")";
            if nvm_has manpath; then
                if [ -z "${MANPATH-}" ]; then
                    local MANPATH;
                    MANPATH=$(manpath);
                fi;
                MANPATH="$(nvm_change_path "${MANPATH}" "/share/man" "${NVM_VERSION_DIR}")";
                export MANPATH;
            fi;
            export PATH;
            hash -r;
            export NVM_BIN="${NVM_VERSION_DIR}/bin";
            export NVM_INC="${NVM_VERSION_DIR}/include/node";
            if [ "${NVM_SYMLINK_CURRENT-}" = true ]; then
                command rm -f "${NVM_DIR}/current" && ln -s "${NVM_VERSION_DIR}" "${NVM_DIR}/current";
            fi;
            local NVM_USE_OUTPUT;
            NVM_USE_OUTPUT='';
            if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                if nvm_is_iojs_version "${VERSION}"; then
                    NVM_USE_OUTPUT="Now using io.js $(nvm_strip_iojs_prefix "${VERSION}")$(nvm_print_npm_version)";
                else
                    NVM_USE_OUTPUT="Now using node ${VERSION}$(nvm_print_npm_version)";
                fi;
            fi;
            if [ "_${VERSION}" != "_system" ]; then
                local NVM_USE_CMD;
                NVM_USE_CMD="nvm use --delete-prefix";
                if [ -n "${PROVIDED_VERSION}" ]; then
                    NVM_USE_CMD="${NVM_USE_CMD} ${VERSION}";
                fi;
                if [ "${NVM_SILENT:-0}" -eq 1 ]; then
                    NVM_USE_CMD="${NVM_USE_CMD} --silent";
                fi;
                if ! nvm_die_on_prefix "${NVM_DELETE_PREFIX}" "${NVM_USE_CMD}" "${NVM_VERSION_DIR}"; then
                    return 11;
                fi;
            fi;
            if [ -n "${NVM_USE_OUTPUT-}" ] && [ "${NVM_SILENT:-0}" -ne 1 ]; then
                nvm_echo "${NVM_USE_OUTPUT}";
            fi
        ;;
        "run")
            local provided_version;
            local has_checked_nvmrc;
            has_checked_nvmrc=0;
            local NVM_SILENT;
            local NVM_SILENT_ARG;
            local NVM_LTS;
            while [ $# -gt 0 ]; do
                case "$1" in 
                    --silent)
                        NVM_SILENT=1;
                        NVM_SILENT_ARG='--silent';
                        shift
                    ;;
                    --lts)
                        NVM_LTS='*';
                        shift
                    ;;
                    --lts=*)
                        NVM_LTS="${1##--lts=}";
                        shift
                    ;;
                    *)
                        if [ -n "$1" ]; then
                            break;
                        else
                            shift;
                        fi
                    ;;
                esac;
            done;
            if [ $# -lt 1 ] && [ -z "${NVM_LTS-}" ]; then
                NVM_SILENT="${NVM_SILENT:-0}" nvm_rc_version && has_checked_nvmrc=1;
                if [ -n "${NVM_RC_VERSION-}" ]; then
                    VERSION="$(nvm_version "${NVM_RC_VERSION-}")" || :;
                fi;
                unset NVM_RC_VERSION;
                if [ "${VERSION:-N/A}" = 'N/A' ]; then
                    nvm --help 1>&2;
                    return 127;
                fi;
            fi;
            if [ -z "${NVM_LTS-}" ]; then
                provided_version="$1";
                if [ -n "${provided_version}" ]; then
                    VERSION="$(nvm_version "${provided_version}")" || :;
                    if [ "_${VERSION:-N/A}" = '_N/A' ] && ! nvm_is_valid_version "${provided_version}"; then
                        provided_version='';
                        if [ $has_checked_nvmrc -ne 1 ]; then
                            NVM_SILENT="${NVM_SILENT:-0}" nvm_rc_version && has_checked_nvmrc=1;
                        fi;
                        VERSION="$(nvm_version "${NVM_RC_VERSION}")" || :;
                        unset NVM_RC_VERSION;
                    else
                        shift;
                    fi;
                fi;
            fi;
            local NVM_IOJS;
            if nvm_is_iojs_version "${VERSION}"; then
                NVM_IOJS=true;
            fi;
            local EXIT_CODE;
            nvm_is_zsh && setopt local_options shwordsplit;
            local LTS_ARG;
            if [ -n "${NVM_LTS-}" ]; then
                LTS_ARG="--lts=${NVM_LTS-}";
                VERSION='';
            fi;
            if [ "_${VERSION}" = "_N/A" ]; then
                nvm_ensure_version_installed "${provided_version}";
            else
                if [ "${NVM_IOJS}" = true ]; then
                    nvm exec "${NVM_SILENT_ARG-}" "${LTS_ARG-}" "${VERSION}" iojs "$@";
                else
                    nvm exec "${NVM_SILENT_ARG-}" "${LTS_ARG-}" "${VERSION}" node "$@";
                fi;
            fi;
            EXIT_CODE="$?";
            return $EXIT_CODE
        ;;
        "exec")
            local NVM_SILENT;
            local NVM_LTS;
            while [ $# -gt 0 ]; do
                case "$1" in 
                    --silent)
                        NVM_SILENT=1;
                        shift
                    ;;
                    --lts)
                        NVM_LTS='*';
                        shift
                    ;;
                    --lts=*)
                        NVM_LTS="${1##--lts=}";
                        shift
                    ;;
                    --)
                        break
                    ;;
                    --*)
                        nvm_err "Unsupported option \"$1\".";
                        return 55
                    ;;
                    *)
                        if [ -n "$1" ]; then
                            break;
                        else
                            shift;
                        fi
                    ;;
                esac;
            done;
            local provided_version;
            provided_version="$1";
            if [ "${NVM_LTS-}" != '' ]; then
                provided_version="lts/${NVM_LTS:-*}";
                VERSION="${provided_version}";
            else
                if [ -n "${provided_version}" ]; then
                    VERSION="$(nvm_version "${provided_version}")" || :;
                    if [ "_${VERSION}" = '_N/A' ] && ! nvm_is_valid_version "${provided_version}"; then
                        NVM_SILENT="${NVM_SILENT:-0}" nvm_rc_version && has_checked_nvmrc=1;
                        provided_version="${NVM_RC_VERSION}";
                        unset NVM_RC_VERSION;
                        VERSION="$(nvm_version "${provided_version}")" || :;
                    else
                        shift;
                    fi;
                fi;
            fi;
            nvm_ensure_version_installed "${provided_version}";
            EXIT_CODE=$?;
            if [ "${EXIT_CODE}" != "0" ]; then
                return $EXIT_CODE;
            fi;
            if [ "${NVM_SILENT:-0}" -ne 1 ]; then
                if [ "${NVM_LTS-}" = '*' ]; then
                    nvm_echo "Running node latest LTS -> $(nvm_version "${VERSION}")$(nvm use --silent "${VERSION}" && nvm_print_npm_version)";
                else
                    if [ -n "${NVM_LTS-}" ]; then
                        nvm_echo "Running node LTS \"${NVM_LTS-}\" -> $(nvm_version "${VERSION}")$(nvm use --silent "${VERSION}" && nvm_print_npm_version)";
                    else
                        if nvm_is_iojs_version "${VERSION}"; then
                            nvm_echo "Running io.js $(nvm_strip_iojs_prefix "${VERSION}")$(nvm use --silent "${VERSION}" && nvm_print_npm_version)";
                        else
                            nvm_echo "Running node ${VERSION}$(nvm use --silent "${VERSION}" && nvm_print_npm_version)";
                        fi;
                    fi;
                fi;
            fi;
            NODE_VERSION="${VERSION}" "${NVM_DIR}/nvm-exec" "$@"
        ;;
        "ls" | "list")
            local PATTERN;
            local NVM_NO_COLORS;
            local NVM_NO_ALIAS;
            while [ $# -gt 0 ]; do
                case "${1}" in 
                    --)

                    ;;
                    --no-colors)
                        NVM_NO_COLORS="${1}"
                    ;;
                    --no-alias)
                        NVM_NO_ALIAS="${1}"
                    ;;
                    --*)
                        nvm_err "Unsupported option \"${1}\".";
                        return 55
                    ;;
                    *)
                        PATTERN="${PATTERN:-$1}"
                    ;;
                esac;
                shift;
            done;
            if [ -n "${PATTERN-}" ] && [ -n "${NVM_NO_ALIAS-}" ]; then
                nvm_err '`--no-alias` is not supported when a pattern is provided.';
                return 55;
            fi;
            local NVM_LS_OUTPUT;
            local NVM_LS_EXIT_CODE;
            NVM_LS_OUTPUT=$(nvm_ls "${PATTERN-}");
            NVM_LS_EXIT_CODE=$?;
            NVM_NO_COLORS="${NVM_NO_COLORS-}" nvm_print_versions "${NVM_LS_OUTPUT}";
            if [ -z "${NVM_NO_ALIAS-}" ] && [ -z "${PATTERN-}" ]; then
                if [ -n "${NVM_NO_COLORS-}" ]; then
                    nvm alias --no-colors;
                else
                    nvm alias;
                fi;
            fi;
            return $NVM_LS_EXIT_CODE
        ;;
        "ls-remote" | "list-remote")
            local NVM_LTS;
            local PATTERN;
            local NVM_NO_COLORS;
            while [ $# -gt 0 ]; do
                case "${1-}" in 
                    --)

                    ;;
                    --lts)
                        NVM_LTS='*'
                    ;;
                    --lts=*)
                        NVM_LTS="${1##--lts=}"
                    ;;
                    --no-colors)
                        NVM_NO_COLORS="${1}"
                    ;;
                    --*)
                        nvm_err "Unsupported option \"${1}\".";
                        return 55
                    ;;
                    *)
                        if [ -z "${PATTERN-}" ]; then
                            PATTERN="${1-}";
                            if [ -z "${NVM_LTS-}" ]; then
                                case "${PATTERN}" in 
                                    'lts/*')
                                        NVM_LTS='*'
                                    ;;
                                    lts/*)
                                        NVM_LTS="${PATTERN##lts/}"
                                    ;;
                                esac;
                            fi;
                        fi
                    ;;
                esac;
                shift;
            done;
            local NVM_OUTPUT;
            local EXIT_CODE;
            NVM_OUTPUT="$(NVM_LTS="${NVM_LTS-}" nvm_remote_versions "${PATTERN}" &&:)";
            EXIT_CODE=$?;
            if [ -n "${NVM_OUTPUT}" ]; then
                NVM_NO_COLORS="${NVM_NO_COLORS-}" nvm_print_versions "${NVM_OUTPUT}";
                return $EXIT_CODE;
            fi;
            NVM_NO_COLORS="${NVM_NO_COLORS-}" nvm_print_versions "N/A";
            return 3
        ;;
        "current")
            nvm_version current
        ;;
        "which")
            local NVM_SILENT;
            local provided_version;
            while [ $# -ne 0 ]; do
                case "${1}" in 
                    --silent)
                        NVM_SILENT=1
                    ;;
                    --)

                    ;;
                    *)
                        provided_version="${1-}"
                    ;;
                esac;
                shift;
            done;
            if [ -z "${provided_version-}" ]; then
                NVM_SILENT="${NVM_SILENT:-0}" nvm_rc_version;
                if [ -n "${NVM_RC_VERSION}" ]; then
                    provided_version="${NVM_RC_VERSION}";
                    VERSION=$(nvm_version "${NVM_RC_VERSION}") || :;
                fi;
                unset NVM_RC_VERSION;
            else
                if [ "${provided_version}" != 'system' ]; then
                    VERSION="$(nvm_version "${provided_version}")" || :;
                else
                    VERSION="${provided_version-}";
                fi;
            fi;
            if [ -z "${VERSION}" ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            if [ "_${VERSION}" = '_system' ]; then
                if nvm_has_system_iojs > /dev/null 2>&1 || nvm_has_system_node > /dev/null 2>&1; then
                    local NVM_BIN;
                    NVM_BIN="$(nvm use system >/dev/null 2>&1 && command which node)";
                    if [ -n "${NVM_BIN}" ]; then
                        nvm_echo "${NVM_BIN}";
                        return;
                    fi;
                    return 1;
                fi;
                nvm_err 'System version of node not found.';
                return 127;
            else
                if [ "${VERSION}" = '∞' ]; then
                    nvm_err "The alias \"${2}\" leads to an infinite loop. Aborting.";
                    return 8;
                fi;
            fi;
            nvm_ensure_version_installed "${provided_version}";
            EXIT_CODE=$?;
            if [ "${EXIT_CODE}" != "0" ]; then
                return $EXIT_CODE;
            fi;
            local NVM_VERSION_DIR;
            NVM_VERSION_DIR="$(nvm_version_path "${VERSION}")";
            nvm_echo "${NVM_VERSION_DIR}/bin/node"
        ;;
        "alias")
            local NVM_ALIAS_DIR;
            NVM_ALIAS_DIR="$(nvm_alias_path)";
            local NVM_CURRENT;
            NVM_CURRENT="$(nvm_ls_current)";
            command mkdir -p "${NVM_ALIAS_DIR}/lts";
            local ALIAS;
            local TARGET;
            local NVM_NO_COLORS;
            ALIAS='--';
            TARGET='--';
            while [ $# -gt 0 ]; do
                case "${1-}" in 
                    --)

                    ;;
                    --no-colors)
                        NVM_NO_COLORS="${1}"
                    ;;
                    --*)
                        nvm_err "Unsupported option \"${1}\".";
                        return 55
                    ;;
                    *)
                        if [ "${ALIAS}" = '--' ]; then
                            ALIAS="${1-}";
                        else
                            if [ "${TARGET}" = '--' ]; then
                                TARGET="${1-}";
                            fi;
                        fi
                    ;;
                esac;
                shift;
            done;
            if [ -z "${TARGET}" ]; then
                nvm unalias "${ALIAS}";
                return $?;
            else
                if [ "${TARGET}" != '--' ]; then
                    if [ "${ALIAS#*\/}" != "${ALIAS}" ]; then
                        nvm_err 'Aliases in subdirectories are not supported.';
                        return 1;
                    fi;
                    VERSION="$(nvm_version "${TARGET}")" || :;
                    if [ "${VERSION}" = 'N/A' ]; then
                        nvm_err "! WARNING: Version '${TARGET}' does not exist.";
                    fi;
                    nvm_make_alias "${ALIAS}" "${TARGET}";
                    NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_CURRENT="${NVM_CURRENT-}" DEFAULT=false nvm_print_formatted_alias "${ALIAS}" "${TARGET}" "${VERSION}";
                else
                    if [ "${ALIAS-}" = '--' ]; then
                        unset ALIAS;
                    fi;
                    nvm_list_aliases "${ALIAS-}";
                fi;
            fi
        ;;
        "unalias")
            local NVM_ALIAS_DIR;
            NVM_ALIAS_DIR="$(nvm_alias_path)";
            command mkdir -p "${NVM_ALIAS_DIR}";
            if [ $# -ne 1 ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            if [ "${1#*\/}" != "${1-}" ]; then
                nvm_err 'Aliases in subdirectories are not supported.';
                return 1;
            fi;
            local NVM_IOJS_PREFIX;
            local NVM_NODE_PREFIX;
            NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
            NVM_NODE_PREFIX="$(nvm_node_prefix)";
            local NVM_ALIAS_EXISTS;
            NVM_ALIAS_EXISTS=0;
            if [ -f "${NVM_ALIAS_DIR}/${1-}" ]; then
                NVM_ALIAS_EXISTS=1;
            fi;
            if [ $NVM_ALIAS_EXISTS -eq 0 ]; then
                case "$1" in 
                    "stable" | "unstable" | "${NVM_IOJS_PREFIX}" | "${NVM_NODE_PREFIX}" | "system")
                        nvm_err "${1-} is a default (built-in) alias and cannot be deleted.";
                        return 1
                    ;;
                esac;
                nvm_err "Alias ${1-} doesn't exist!";
                return;
            fi;
            local NVM_ALIAS_ORIGINAL;
            NVM_ALIAS_ORIGINAL="$(nvm_alias "${1}")";
            command rm -f "${NVM_ALIAS_DIR}/${1}";
            nvm_echo "Deleted alias ${1} - restore it with \`nvm alias \"${1}\" \"${NVM_ALIAS_ORIGINAL}\"\`"
        ;;
        "install-latest-npm")
            if [ $# -ne 0 ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            nvm_install_latest_npm
        ;;
        "reinstall-packages" | "copy-packages")
            if [ $# -ne 1 ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            local PROVIDED_VERSION;
            PROVIDED_VERSION="${1-}";
            if [ "${PROVIDED_VERSION}" = "$(nvm_ls_current)" ] || [ "$(nvm_version "${PROVIDED_VERSION}" ||:)" = "$(nvm_ls_current)" ]; then
                nvm_err 'Can not reinstall packages from the current version of node.';
                return 2;
            fi;
            local VERSION;
            if [ "_${PROVIDED_VERSION}" = "_system" ]; then
                if ! nvm_has_system_node && ! nvm_has_system_iojs; then
                    nvm_err 'No system version of node or io.js detected.';
                    return 3;
                fi;
                VERSION="system";
            else
                VERSION="$(nvm_version "${PROVIDED_VERSION}")" || :;
            fi;
            local NPMLIST;
            NPMLIST="$(nvm_npm_global_modules "${VERSION}")";
            local INSTALLS;
            local LINKS;
            INSTALLS="${NPMLIST%% //// *}";
            LINKS="${NPMLIST##* //// }";
            nvm_echo "Reinstalling global packages from ${VERSION}...";
            if [ -n "${INSTALLS}" ]; then
                nvm_echo "${INSTALLS}" | command xargs npm install -g --quiet;
            else
                nvm_echo "No installed global packages found...";
            fi;
            nvm_echo "Linking global packages from ${VERSION}...";
            if [ -n "${LINKS}" ]; then
                ( set -f;
                IFS='
';
                for LINK in ${LINKS};
                do
                    set +f;
                    unset IFS;
                    if [ -n "${LINK}" ]; then
                        ( nvm_cd "${LINK}" && npm link );
                    fi;
                done );
            else
                nvm_echo "No linked global packages found...";
            fi
        ;;
        "clear-cache")
            command rm -f "${NVM_DIR}/v*" "$(nvm_version_dir)" 2> /dev/null;
            nvm_echo 'nvm cache cleared.'
        ;;
        "version")
            nvm_version "${1}"
        ;;
        "version-remote")
            local NVM_LTS;
            local PATTERN;
            while [ $# -gt 0 ]; do
                case "${1-}" in 
                    --)

                    ;;
                    --lts)
                        NVM_LTS='*'
                    ;;
                    --lts=*)
                        NVM_LTS="${1##--lts=}"
                    ;;
                    --*)
                        nvm_err "Unsupported option \"${1}\".";
                        return 55
                    ;;
                    *)
                        PATTERN="${PATTERN:-${1}}"
                    ;;
                esac;
                shift;
            done;
            case "${PATTERN-}" in 
                'lts/*')
                    NVM_LTS='*';
                    unset PATTERN
                ;;
                lts/*)
                    NVM_LTS="${PATTERN##lts/}";
                    unset PATTERN
                ;;
            esac;
            NVM_VERSION_ONLY=true NVM_LTS="${NVM_LTS-}" nvm_remote_version "${PATTERN:-node}"
        ;;
        "--version" | "-v")
            nvm_echo '0.38.0'
        ;;
        "unload")
            nvm deactivate > /dev/null 2>&1;
            unset -f nvm nvm_iojs_prefix nvm_node_prefix nvm_add_iojs_prefix nvm_strip_iojs_prefix nvm_is_iojs_version nvm_is_alias nvm_has_non_aliased nvm_ls_remote nvm_ls_remote_iojs nvm_ls_remote_index_tab nvm_ls nvm_remote_version nvm_remote_versions nvm_install_binary nvm_install_source nvm_clang_version nvm_get_mirror nvm_get_download_slug nvm_download_artifact nvm_install_npm_if_needed nvm_use_if_needed nvm_check_file_permissions nvm_print_versions nvm_compute_checksum nvm_get_checksum_binary nvm_get_checksum_alg nvm_get_checksum nvm_compare_checksum nvm_version nvm_rc_version nvm_match_version nvm_ensure_default_set nvm_get_arch nvm_get_os nvm_print_implicit_alias nvm_validate_implicit_alias nvm_resolve_alias nvm_ls_current nvm_alias nvm_binary_available nvm_change_path nvm_strip_path nvm_num_version_groups nvm_format_version nvm_ensure_version_prefix nvm_normalize_version nvm_is_valid_version nvm_ensure_version_installed nvm_cache_dir nvm_version_path nvm_alias_path nvm_version_dir nvm_find_nvmrc nvm_find_up nvm_find_project_dir nvm_tree_contains_path nvm_version_greater nvm_version_greater_than_or_equal_to nvm_print_npm_version nvm_install_latest_npm nvm_npm_global_modules nvm_has_system_node nvm_has_system_iojs nvm_download nvm_get_latest nvm_has nvm_install_default_packages nvm_get_default_packages nvm_curl_use_compression nvm_curl_version nvm_auto nvm_supports_xz nvm_echo nvm_err nvm_grep nvm_cd nvm_die_on_prefix nvm_get_make_jobs nvm_get_minor_version nvm_has_solaris_binary nvm_is_merged_node_version nvm_is_natural_num nvm_is_version_installed nvm_list_aliases nvm_make_alias nvm_print_alias_path nvm_print_default_alias nvm_print_formatted_alias nvm_resolve_local_alias nvm_sanitize_path nvm_has_colors nvm_process_parameters nvm_node_version_has_solaris_binary nvm_iojs_version_has_solaris_binary nvm_curl_libz_support nvm_command_info nvm_is_zsh nvm_stdout_is_terminal nvm_npmrc_bad_news_bears nvm_get_colors nvm_set_colors nvm_print_color_code nvm_format_help_message_colors nvm_echo_with_colors nvm_err_with_colors nvm_get_artifact_compression nvm_install_binary_extract > /dev/null 2>&1;
            unset NVM_RC_VERSION NVM_NODEJS_ORG_MIRROR NVM_IOJS_ORG_MIRROR NVM_DIR NVM_CD_FLAGS NVM_BIN NVM_INC NVM_MAKE_JOBS NVM_COLORS INSTALLED_COLOR SYSTEM_COLOR CURRENT_COLOR NOT_INSTALLED_COLOR DEFAULT_COLOR LTS_COLOR > /dev/null 2>&1
        ;;
        "set-colors")
            local EXIT_CODE;
            nvm_set_colors "${1-}";
            EXIT_CODE=$?;
            if [ "$EXIT_CODE" -eq 17 ]; then
                nvm --help 1>&2;
                nvm_echo;
                nvm_err_with_colors "\033[1;37mPlease pass in five \033[1;31mvalid color codes\033[1;37m. Choose from: rRgGbBcCyYmMkKeW\033[0m";
            fi
        ;;
        *)
            nvm --help 1>&2;
            return 127
        ;;
    esac
}
nvm_add_iojs_prefix () 
{ 
    nvm_echo "$(nvm_iojs_prefix)-$(nvm_ensure_version_prefix "$(nvm_strip_iojs_prefix "${1-}")")"
}
nvm_alias () 
{ 
    local ALIAS;
    ALIAS="${1-}";
    if [ -z "${ALIAS}" ]; then
        nvm_err 'An alias is required.';
        return 1;
    fi;
    local NVM_ALIAS_DIR;
    NVM_ALIAS_DIR="$(nvm_alias_path)";
    if [ "$(expr "${ALIAS}" : '^lts/-[1-9][0-9]*$')" -gt 0 ]; then
        local N;
        N="$(echo "${ALIAS}" | cut -d '-' -f 2)";
        N=$((N+1));
        local RESULT;
        RESULT="$(command ls "${NVM_ALIAS_DIR}/lts" | command tail -n "${N}" | command head -n 1)";
        if [ "${RESULT}" != '*' ]; then
            nvm_alias "lts/${RESULT}";
            return $?;
        else
            nvm_err 'That many LTS releases do not exist yet.';
            return 2;
        fi;
    fi;
    local NVM_ALIAS_PATH;
    NVM_ALIAS_PATH="${NVM_ALIAS_DIR}/${ALIAS}";
    if [ ! -f "${NVM_ALIAS_PATH}" ]; then
        nvm_err 'Alias does not exist.';
        return 2;
    fi;
    command cat "${NVM_ALIAS_PATH}"
}
nvm_alias_path () 
{ 
    nvm_echo "$(nvm_version_dir old)/alias"
}
nvm_auto () 
{ 
    local NVM_MODE;
    NVM_MODE="${1-}";
    local VERSION;
    local NVM_CURRENT;
    if [ "_${NVM_MODE}" = '_install' ]; then
        VERSION="$(nvm_alias default 2>/dev/null || nvm_echo)";
        if [ -n "${VERSION}" ]; then
            nvm install "${VERSION}" > /dev/null;
        else
            if nvm_rc_version > /dev/null 2>&1; then
                nvm install > /dev/null;
            fi;
        fi;
    else
        if [ "_$NVM_MODE" = '_use' ]; then
            NVM_CURRENT="$(nvm_ls_current)";
            if [ "_${NVM_CURRENT}" = '_none' ] || [ "_${NVM_CURRENT}" = '_system' ]; then
                VERSION="$(nvm_resolve_local_alias default 2>/dev/null || nvm_echo)";
                if [ -n "${VERSION}" ]; then
                    nvm use --silent "${VERSION}" > /dev/null;
                else
                    if nvm_rc_version > /dev/null 2>&1; then
                        nvm use --silent > /dev/null;
                    fi;
                fi;
            else
                nvm use --silent "${NVM_CURRENT}" > /dev/null;
            fi;
        else
            if [ "_${NVM_MODE}" != '_none' ]; then
                nvm_err 'Invalid auto mode supplied.';
                return 1;
            fi;
        fi;
    fi
}
nvm_binary_available () 
{ 
    nvm_version_greater_than_or_equal_to "$(nvm_strip_iojs_prefix "${1-}")" v0.8.6
}
nvm_cache_dir () 
{ 
    nvm_echo "${NVM_DIR}/.cache"
}
nvm_cd () 
{ 
    \cd "$@"
}
nvm_change_path () 
{ 
    if [ -z "${1-}" ]; then
        nvm_echo "${3-}${2-}";
    else
        if ! nvm_echo "${1-}" | nvm_grep -q "${NVM_DIR}/[^/]*${2-}" && ! nvm_echo "${1-}" | nvm_grep -q "${NVM_DIR}/versions/[^/]*/[^/]*${2-}"; then
            nvm_echo "${3-}${2-}:${1-}";
        else
            if nvm_echo "${1-}" | nvm_grep -Eq "(^|:)(/usr(/local)?)?${2-}:.*${NVM_DIR}/[^/]*${2-}" || nvm_echo "${1-}" | nvm_grep -Eq "(^|:)(/usr(/local)?)?${2-}:.*${NVM_DIR}/versions/[^/]*/[^/]*${2-}"; then
                nvm_echo "${3-}${2-}:${1-}";
            else
                nvm_echo "${1-}" | command sed -e "s#${NVM_DIR}/[^/]*${2-}[^:]*#${3-}${2-}#" -e "s#${NVM_DIR}/versions/[^/]*/[^/]*${2-}[^:]*#${3-}${2-}#";
            fi;
        fi;
    fi
}
nvm_check_file_permissions () 
{ 
    nvm_is_zsh && setopt local_options nonomatch;
    for FILE in "$1"/* "$1"/.[!.]* "$1"/..?*;
    do
        if [ -d "$FILE" ]; then
            if [ -n "${NVM_DEBUG-}" ]; then
                nvm_err "${FILE}";
            fi;
            if ! nvm_check_file_permissions "${FILE}"; then
                return 2;
            fi;
        else
            if [ -e "$FILE" ] && [ ! -w "$FILE" ] && [ ! -O "$FILE" ]; then
                nvm_err "file is not writable or self-owned: $(nvm_sanitize_path "$FILE")";
                return 1;
            fi;
        fi;
    done;
    return 0
}
nvm_clang_version () 
{ 
    clang --version | command awk '{ if ($2 == "version") print $3; else if ($3 == "version") print $4 }' | command sed 's/-.*$//g'
}
nvm_command_info () 
{ 
    local COMMAND;
    local INFO;
    COMMAND="${1}";
    if type "${COMMAND}" | nvm_grep -q hashed; then
        INFO="$(type "${COMMAND}" | command sed -E 's/\(|\)//g' | command awk '{print $4}')";
    else
        if type "${COMMAND}" | nvm_grep -q aliased; then
            INFO="$(which "${COMMAND}") ($(type "${COMMAND}" | command awk '{ $1=$2=$3=$4="" ;print }' | command sed -e 's/^\ *//g' -Ee "s/\`|'//g"))";
        else
            if type "${COMMAND}" | nvm_grep -q "^${COMMAND} is an alias for"; then
                INFO="$(which "${COMMAND}") ($(type "${COMMAND}" | command awk '{ $1=$2=$3=$4=$5="" ;print }' | command sed 's/^\ *//g'))";
            else
                if type "${COMMAND}" | nvm_grep -q "^${COMMAND} is \\/"; then
                    INFO="$(type "${COMMAND}" | command awk '{print $3}')";
                else
                    INFO="$(type "${COMMAND}")";
                fi;
            fi;
        fi;
    fi;
    nvm_echo "${INFO}"
}
nvm_compare_checksum () 
{ 
    local FILE;
    FILE="${1-}";
    if [ -z "${FILE}" ]; then
        nvm_err 'Provided file to checksum is empty.';
        return 4;
    else
        if ! [ -f "${FILE}" ]; then
            nvm_err 'Provided file to checksum does not exist.';
            return 3;
        fi;
    fi;
    local COMPUTED_SUM;
    COMPUTED_SUM="$(nvm_compute_checksum "${FILE}")";
    local CHECKSUM;
    CHECKSUM="${2-}";
    if [ -z "${CHECKSUM}" ]; then
        nvm_err 'Provided checksum to compare to is empty.';
        return 2;
    fi;
    if [ -z "${COMPUTED_SUM}" ]; then
        nvm_err "Computed checksum of '${FILE}' is empty.";
        nvm_err 'WARNING: Continuing *without checksum verification*';
        return;
    else
        if [ "${COMPUTED_SUM}" != "${CHECKSUM}" ]; then
            nvm_err "Checksums do not match: '${COMPUTED_SUM}' found, '${CHECKSUM}' expected.";
            return 1;
        fi;
    fi;
    nvm_err 'Checksums matched!'
}
nvm_compute_checksum () 
{ 
    local FILE;
    FILE="${1-}";
    if [ -z "${FILE}" ]; then
        nvm_err 'Provided file to checksum is empty.';
        return 2;
    else
        if ! [ -f "${FILE}" ]; then
            nvm_err 'Provided file to checksum does not exist.';
            return 1;
        fi;
    fi;
    if nvm_has_non_aliased "sha256sum"; then
        nvm_err 'Computing checksum with sha256sum';
        command sha256sum "${FILE}" | command awk '{print $1}';
    else
        if nvm_has_non_aliased "shasum"; then
            nvm_err 'Computing checksum with shasum -a 256';
            command shasum -a 256 "${FILE}" | command awk '{print $1}';
        else
            if nvm_has_non_aliased "sha256"; then
                nvm_err 'Computing checksum with sha256 -q';
                command sha256 -q "${FILE}" | command awk '{print $1}';
            else
                if nvm_has_non_aliased "gsha256sum"; then
                    nvm_err 'Computing checksum with gsha256sum';
                    command gsha256sum "${FILE}" | command awk '{print $1}';
                else
                    if nvm_has_non_aliased "openssl"; then
                        nvm_err 'Computing checksum with openssl dgst -sha256';
                        command openssl dgst -sha256 "${FILE}" | command awk '{print $NF}';
                    else
                        if nvm_has_non_aliased "bssl"; then
                            nvm_err 'Computing checksum with bssl sha256sum';
                            command bssl sha256sum "${FILE}" | command awk '{print $1}';
                        else
                            if nvm_has_non_aliased "sha1sum"; then
                                nvm_err 'Computing checksum with sha1sum';
                                command sha1sum "${FILE}" | command awk '{print $1}';
                            else
                                if nvm_has_non_aliased "sha1"; then
                                    nvm_err 'Computing checksum with sha1 -q';
                                    command sha1 -q "${FILE}";
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi
}
nvm_curl_libz_support () 
{ 
    curl -V 2> /dev/null | nvm_grep "^Features:" | nvm_grep -q "libz"
}
nvm_curl_use_compression () 
{ 
    nvm_curl_libz_support && nvm_version_greater_than_or_equal_to "$(nvm_curl_version)" 7.21.0
}
nvm_curl_version () 
{ 
    curl -V | command awk '{ if ($1 == "curl") print $2 }' | command sed 's/-.*$//g'
}
nvm_die_on_prefix () 
{ 
    local NVM_DELETE_PREFIX;
    NVM_DELETE_PREFIX="${1-}";
    case "${NVM_DELETE_PREFIX}" in 
        0 | 1)

        ;;
        *)
            nvm_err 'First argument "delete the prefix" must be zero or one';
            return 1
        ;;
    esac;
    local NVM_COMMAND;
    NVM_COMMAND="${2-}";
    local NVM_VERSION_DIR;
    NVM_VERSION_DIR="${3-}";
    if [ -z "${NVM_COMMAND}" ] || [ -z "${NVM_VERSION_DIR}" ]; then
        nvm_err 'Second argument "nvm command", and third argument "nvm version dir", must both be nonempty';
        return 2;
    fi;
    if [ -n "${PREFIX-}" ] && [ "$(nvm_version_path "$(node -v)")" != "${PREFIX}" ]; then
        nvm deactivate > /dev/null 2>&1;
        nvm_err "nvm is not compatible with the \"PREFIX\" environment variable: currently set to \"${PREFIX}\"";
        nvm_err 'Run `unset PREFIX` to unset it.';
        return 3;
    fi;
    local NVM_NPM_CONFIG_PREFIX_ENV;
    NVM_NPM_CONFIG_PREFIX_ENV="$(command env | nvm_grep -i NPM_CONFIG_PREFIX | command tail -1 | command awk -F '=' '{print $1}')";
    if [ -n "${NVM_NPM_CONFIG_PREFIX_ENV-}" ]; then
        local NVM_CONFIG_VALUE;
        eval "NVM_CONFIG_VALUE=\"\$${NVM_NPM_CONFIG_PREFIX_ENV}\"";
        if [ -n "${NVM_CONFIG_VALUE-}" ] && ! nvm_tree_contains_path "${NVM_DIR}" "${NVM_CONFIG_VALUE}"; then
            nvm deactivate > /dev/null 2>&1;
            nvm_err "nvm is not compatible with the \"${NVM_NPM_CONFIG_PREFIX_ENV}\" environment variable: currently set to \"${NVM_CONFIG_VALUE}\"";
            nvm_err "Run \`unset ${NVM_NPM_CONFIG_PREFIX_ENV}\` to unset it.";
            return 4;
        fi;
    fi;
    local NVM_NPM_BUILTIN_NPMRC;
    NVM_NPM_BUILTIN_NPMRC="${NVM_VERSION_DIR}/lib/node_modules/npm/npmrc";
    if nvm_npmrc_bad_news_bears "${NVM_NPM_BUILTIN_NPMRC}"; then
        if [ "_${NVM_DELETE_PREFIX}" = "_1" ]; then
            npm config --loglevel=warn delete prefix --userconfig="${NVM_NPM_BUILTIN_NPMRC}";
            npm config --loglevel=warn delete globalconfig --userconfig="${NVM_NPM_BUILTIN_NPMRC}";
        else
            nvm_err "Your builtin npmrc file ($(nvm_sanitize_path "${NVM_NPM_BUILTIN_NPMRC}"))";
            nvm_err 'has a `globalconfig` and/or a `prefix` setting, which are incompatible with nvm.';
            nvm_err "Run \`${NVM_COMMAND}\` to unset it.";
            return 10;
        fi;
    fi;
    local NVM_NPM_GLOBAL_NPMRC;
    NVM_NPM_GLOBAL_NPMRC="${NVM_VERSION_DIR}/etc/npmrc";
    if nvm_npmrc_bad_news_bears "${NVM_NPM_GLOBAL_NPMRC}"; then
        if [ "_${NVM_DELETE_PREFIX}" = "_1" ]; then
            npm config --global --loglevel=warn delete prefix;
            npm config --global --loglevel=warn delete globalconfig;
        else
            nvm_err "Your global npmrc file ($(nvm_sanitize_path "${NVM_NPM_GLOBAL_NPMRC}"))";
            nvm_err 'has a `globalconfig` and/or a `prefix` setting, which are incompatible with nvm.';
            nvm_err "Run \`${NVM_COMMAND}\` to unset it.";
            return 10;
        fi;
    fi;
    local NVM_NPM_USER_NPMRC;
    NVM_NPM_USER_NPMRC="${HOME}/.npmrc";
    if nvm_npmrc_bad_news_bears "${NVM_NPM_USER_NPMRC}"; then
        if [ "_${NVM_DELETE_PREFIX}" = "_1" ]; then
            npm config --loglevel=warn delete prefix --userconfig="${NVM_NPM_USER_NPMRC}";
            npm config --loglevel=warn delete globalconfig --userconfig="${NVM_NPM_USER_NPMRC}";
        else
            nvm_err "Your user’s .npmrc file ($(nvm_sanitize_path "${NVM_NPM_USER_NPMRC}"))";
            nvm_err 'has a `globalconfig` and/or a `prefix` setting, which are incompatible with nvm.';
            nvm_err "Run \`${NVM_COMMAND}\` to unset it.";
            return 10;
        fi;
    fi;
    local NVM_NPM_PROJECT_NPMRC;
    NVM_NPM_PROJECT_NPMRC="$(nvm_find_project_dir)/.npmrc";
    if nvm_npmrc_bad_news_bears "${NVM_NPM_PROJECT_NPMRC}"; then
        if [ "_${NVM_DELETE_PREFIX}" = "_1" ]; then
            npm config --loglevel=warn delete prefix;
            npm config --loglevel=warn delete globalconfig;
        else
            nvm_err "Your project npmrc file ($(nvm_sanitize_path "${NVM_NPM_PROJECT_NPMRC}"))";
            nvm_err 'has a `globalconfig` and/or a `prefix` setting, which are incompatible with nvm.';
            nvm_err "Run \`${NVM_COMMAND}\` to unset it.";
            return 10;
        fi;
    fi
}
nvm_download () 
{ 
    local CURL_COMPRESSED_FLAG;
    if nvm_has "curl"; then
        if nvm_curl_use_compression; then
            CURL_COMPRESSED_FLAG="--compressed";
        fi;
        curl --fail ${CURL_COMPRESSED_FLAG:-} -q "$@";
    else
        if nvm_has "wget"; then
            ARGS=$(nvm_echo "$@" | command sed -e 's/--progress-bar /--progress=bar /'                             -e 's/--compressed //'                             -e 's/--fail //'                             -e 's/-L //'                             -e 's/-I /--server-response /'                             -e 's/-s /-q /'                             -e 's/-sS /-nv /'                             -e 's/-o /-O /'                             -e 's/-C - /-c /');
            eval wget $ARGS;
        fi;
    fi
}
nvm_download_artifact () 
{ 
    local FLAVOR;
    case "${1-}" in 
        node | iojs)
            FLAVOR="${1}"
        ;;
        *)
            nvm_err 'supported flavors: node, iojs';
            return 1
        ;;
    esac;
    local KIND;
    case "${2-}" in 
        binary | source)
            KIND="${2}"
        ;;
        *)
            nvm_err 'supported kinds: binary, source';
            return 1
        ;;
    esac;
    local TYPE;
    TYPE="${3-}";
    local MIRROR;
    MIRROR="$(nvm_get_mirror "${FLAVOR}" "${TYPE}")";
    if [ -z "${MIRROR}" ]; then
        return 2;
    fi;
    local VERSION;
    VERSION="${4}";
    if [ -z "${VERSION}" ]; then
        nvm_err 'A version number is required.';
        return 3;
    fi;
    if [ "${KIND}" = 'binary' ] && ! nvm_binary_available "${VERSION}"; then
        nvm_err "No precompiled binary available for ${VERSION}.";
        return;
    fi;
    local SLUG;
    SLUG="$(nvm_get_download_slug "${FLAVOR}" "${KIND}" "${VERSION}")";
    local COMPRESSION;
    COMPRESSION="$(nvm_get_artifact_compression "${VERSION}")";
    local CHECKSUM;
    CHECKSUM="$(nvm_get_checksum "${FLAVOR}" "${TYPE}" "${VERSION}" "${SLUG}" "${COMPRESSION}")";
    local tmpdir;
    if [ "${KIND}" = 'binary' ]; then
        tmpdir="$(nvm_cache_dir)/bin/${SLUG}";
    else
        tmpdir="$(nvm_cache_dir)/src/${SLUG}";
    fi;
    command mkdir -p "${tmpdir}/files" || ( nvm_err "creating directory ${tmpdir}/files failed";
    return 3 );
    local TARBALL;
    TARBALL="${tmpdir}/${SLUG}.${COMPRESSION}";
    local TARBALL_URL;
    if nvm_version_greater_than_or_equal_to "${VERSION}" 0.1.14; then
        TARBALL_URL="${MIRROR}/${VERSION}/${SLUG}.${COMPRESSION}";
    else
        TARBALL_URL="${MIRROR}/${SLUG}.${COMPRESSION}";
    fi;
    if [ -r "${TARBALL}" ]; then
        nvm_err "Local cache found: $(nvm_sanitize_path "${TARBALL}")";
        if nvm_compare_checksum "${TARBALL}" "${CHECKSUM}" > /dev/null 2>&1; then
            nvm_err "Checksums match! Using existing downloaded archive $(nvm_sanitize_path "${TARBALL}")";
            nvm_echo "${TARBALL}";
            return 0;
        fi;
        nvm_compare_checksum "${TARBALL}" "${CHECKSUM}";
        nvm_err "Checksum check failed!";
        nvm_err "Removing the broken local cache...";
        command rm -rf "${TARBALL}";
    fi;
    nvm_err "Downloading ${TARBALL_URL}...";
    nvm_download -L -C - "${PROGRESS_BAR}" "${TARBALL_URL}" -o "${TARBALL}" || ( command rm -rf "${TARBALL}" "${tmpdir}";
    nvm_err "Binary download from ${TARBALL_URL} failed, trying source.";
    return 4 );
    if nvm_grep '404 Not Found' "${TARBALL}" > /dev/null; then
        command rm -rf "${TARBALL}" "${tmpdir}";
        nvm_err "HTTP 404 at URL ${TARBALL_URL}";
        return 5;
    fi;
    nvm_compare_checksum "${TARBALL}" "${CHECKSUM}" || ( command rm -rf "${tmpdir}/files";
    return 6 );
    nvm_echo "${TARBALL}"
}
nvm_echo () 
{ 
    command printf %s\\n "$*" 2> /dev/null
}
nvm_echo_with_colors () 
{ 
    command printf %b\\n "$*" 2> /dev/null
}
nvm_ensure_default_set () 
{ 
    local VERSION;
    VERSION="$1";
    if [ -z "${VERSION}" ]; then
        nvm_err 'nvm_ensure_default_set: a version is required';
        return 1;
    else
        if nvm_alias default > /dev/null 2>&1; then
            return 0;
        fi;
    fi;
    local OUTPUT;
    OUTPUT="$(nvm alias default "${VERSION}")";
    local EXIT_CODE;
    EXIT_CODE="$?";
    nvm_echo "Creating default alias: ${OUTPUT}";
    return $EXIT_CODE
}
nvm_ensure_version_installed () 
{ 
    local PROVIDED_VERSION;
    PROVIDED_VERSION="${1-}";
    if [ "${PROVIDED_VERSION}" = 'system' ]; then
        if nvm_has_system_iojs || nvm_has_system_node; then
            return 0;
        fi;
        nvm_err "N/A: no system version of node/io.js is installed.";
        return 1;
    fi;
    local LOCAL_VERSION;
    local EXIT_CODE;
    LOCAL_VERSION="$(nvm_version "${PROVIDED_VERSION}")";
    EXIT_CODE="$?";
    local NVM_VERSION_DIR;
    if [ "${EXIT_CODE}" != "0" ] || ! nvm_is_version_installed "${LOCAL_VERSION}"; then
        if VERSION="$(nvm_resolve_alias "${PROVIDED_VERSION}")"; then
            nvm_err "N/A: version \"${PROVIDED_VERSION} -> ${VERSION}\" is not yet installed.";
        else
            local PREFIXED_VERSION;
            PREFIXED_VERSION="$(nvm_ensure_version_prefix "${PROVIDED_VERSION}")";
            nvm_err "N/A: version \"${PREFIXED_VERSION:-$PROVIDED_VERSION}\" is not yet installed.";
        fi;
        nvm_err "";
        nvm_err "You need to run \"nvm install ${PROVIDED_VERSION}\" to install it before using it.";
        return 1;
    fi
}
nvm_ensure_version_prefix () 
{ 
    local NVM_VERSION;
    NVM_VERSION="$(nvm_strip_iojs_prefix "${1-}" | command sed -e 's/^\([0-9]\)/v\1/g')";
    if nvm_is_iojs_version "${1-}"; then
        nvm_add_iojs_prefix "${NVM_VERSION}";
    else
        nvm_echo "${NVM_VERSION}";
    fi
}
nvm_err () 
{ 
    nvm_echo "$@" 1>&2
}
nvm_err_with_colors () 
{ 
    nvm_echo_with_colors "$@" 1>&2
}
nvm_find_nvmrc () 
{ 
    local dir;
    dir="$(nvm_find_up '.nvmrc')";
    if [ -e "${dir}/.nvmrc" ]; then
        nvm_echo "${dir}/.nvmrc";
    fi
}
nvm_find_project_dir () 
{ 
    local path_;
    path_="${PWD}";
    while [ "${path_}" != "" ] && [ ! -f "${path_}/package.json" ] && [ ! -d "${path_}/node_modules" ]; do
        path_=${path_%/*};
    done;
    nvm_echo "${path_}"
}
nvm_find_up () 
{ 
    local path_;
    path_="${PWD}";
    while [ "${path_}" != "" ] && [ ! -f "${path_}/${1-}" ]; do
        path_=${path_%/*};
    done;
    nvm_echo "${path_}"
}
nvm_format_version () 
{ 
    local VERSION;
    VERSION="$(nvm_ensure_version_prefix "${1-}")";
    local NUM_GROUPS;
    NUM_GROUPS="$(nvm_num_version_groups "${VERSION}")";
    if [ "${NUM_GROUPS}" -lt 3 ]; then
        nvm_format_version "${VERSION%.}.0";
    else
        nvm_echo "${VERSION}" | command cut -f1-3 -d.;
    fi
}
nvm_get_arch () 
{ 
    local HOST_ARCH;
    local NVM_OS;
    local EXIT_CODE;
    NVM_OS="$(nvm_get_os)";
    if [ "_${NVM_OS}" = "_sunos" ]; then
        if HOST_ARCH=$(pkg_info -Q MACHINE_ARCH pkg_install); then
            HOST_ARCH=$(nvm_echo "${HOST_ARCH}" | command tail -1);
        else
            HOST_ARCH=$(isainfo -n);
        fi;
    else
        if [ "_${NVM_OS}" = "_aix" ]; then
            HOST_ARCH=ppc64;
        else
            HOST_ARCH="$(command uname -m)";
        fi;
    fi;
    local NVM_ARCH;
    case "${HOST_ARCH}" in 
        x86_64 | amd64)
            NVM_ARCH="x64"
        ;;
        i*86)
            NVM_ARCH="x86"
        ;;
        aarch64)
            NVM_ARCH="arm64"
        ;;
        *)
            NVM_ARCH="${HOST_ARCH}"
        ;;
    esac;
    nvm_echo "${NVM_ARCH}"
}
nvm_get_artifact_compression () 
{ 
    local VERSION;
    VERSION="${1-}";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local COMPRESSION;
    COMPRESSION='tar.gz';
    if nvm_supports_xz "${VERSION}"; then
        COMPRESSION='tar.xz';
    fi;
    nvm_echo "${COMPRESSION}"
}
nvm_get_checksum () 
{ 
    local FLAVOR;
    case "${1-}" in 
        node | iojs)
            FLAVOR="${1}"
        ;;
        *)
            nvm_err 'supported flavors: node, iojs';
            return 2
        ;;
    esac;
    local MIRROR;
    MIRROR="$(nvm_get_mirror "${FLAVOR}" "${2-}")";
    if [ -z "${MIRROR}" ]; then
        return 1;
    fi;
    local SHASUMS_URL;
    if [ "$(nvm_get_checksum_alg)" = 'sha-256' ]; then
        SHASUMS_URL="${MIRROR}/${3}/SHASUMS256.txt";
    else
        SHASUMS_URL="${MIRROR}/${3}/SHASUMS.txt";
    fi;
    nvm_download -L -s "${SHASUMS_URL}" -o - | command awk "{ if (\"${4}.${5}\" == \$2) print \$1}"
}
nvm_get_checksum_alg () 
{ 
    local NVM_CHECKSUM_BIN;
    NVM_CHECKSUM_BIN="$(nvm_get_checksum_binary 2>/dev/null)";
    case "${NVM_CHECKSUM_BIN-}" in 
        sha256sum | shasum | sha256 | gsha256sum | openssl | bssl)
            nvm_echo 'sha-256'
        ;;
        sha1sum | sha1)
            nvm_echo 'sha-1'
        ;;
        *)
            nvm_get_checksum_binary;
            return $?
        ;;
    esac
}
nvm_get_checksum_binary () 
{ 
    if nvm_has_non_aliased 'sha256sum'; then
        nvm_echo 'sha256sum';
    else
        if nvm_has_non_aliased 'shasum'; then
            nvm_echo 'shasum';
        else
            if nvm_has_non_aliased 'sha256'; then
                nvm_echo 'sha256';
            else
                if nvm_has_non_aliased 'gsha256sum'; then
                    nvm_echo 'gsha256sum';
                else
                    if nvm_has_non_aliased 'openssl'; then
                        nvm_echo 'openssl';
                    else
                        if nvm_has_non_aliased 'bssl'; then
                            nvm_echo 'bssl';
                        else
                            if nvm_has_non_aliased 'sha1sum'; then
                                nvm_echo 'sha1sum';
                            else
                                if nvm_has_non_aliased 'sha1'; then
                                    nvm_echo 'sha1';
                                else
                                    nvm_err 'Unaliased sha256sum, shasum, sha256, gsha256sum, openssl, or bssl not found.';
                                    nvm_err 'Unaliased sha1sum or sha1 not found.';
                                    return 1;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi
}
nvm_get_colors () 
{ 
    local COLOR;
    local SYS_COLOR;
    if [ -n "${NVM_COLORS-}" ]; then
        case $1 in 
            1)
                COLOR=$(nvm_print_color_code "$(echo "$NVM_COLORS" | awk '{ print substr($0, 1, 1); }')")
            ;;
            2)
                COLOR=$(nvm_print_color_code "$(echo "$NVM_COLORS" | awk '{ print substr($0, 2, 1); }')")
            ;;
            3)
                COLOR=$(nvm_print_color_code "$(echo "$NVM_COLORS" | awk '{ print substr($0, 3, 1); }')")
            ;;
            4)
                COLOR=$(nvm_print_color_code "$(echo "$NVM_COLORS" | awk '{ print substr($0, 4, 1); }')")
            ;;
            5)
                COLOR=$(nvm_print_color_code "$(echo "$NVM_COLORS" | awk '{ print substr($0, 5, 1); }')")
            ;;
            6)
                SYS_COLOR=$(nvm_print_color_code "$(echo "$NVM_COLORS" | awk '{ print substr($0, 2, 1); }')");
                COLOR=$(nvm_echo "$SYS_COLOR" | command tr '0;' '1;')
            ;;
            *)
                nvm_err "Invalid color index, ${1-}";
                return 1
            ;;
        esac;
    else
        case $1 in 
            1)
                COLOR='0;34m'
            ;;
            2)
                COLOR='0;33m'
            ;;
            3)
                COLOR='0;32m'
            ;;
            4)
                COLOR='0;31m'
            ;;
            5)
                COLOR='0;37m'
            ;;
            6)
                COLOR='1;33m'
            ;;
            *)
                nvm_err "Invalid color index, ${1-}";
                return 1
            ;;
        esac;
    fi;
    echo "$COLOR"
}
nvm_get_default_packages () 
{ 
    local NVM_DEFAULT_PACKAGE_FILE="${NVM_DIR}/default-packages";
    if [ -f "${NVM_DEFAULT_PACKAGE_FILE}" ]; then
        local DEFAULT_PACKAGES;
        DEFAULT_PACKAGES='';
        local line;
        WORK=$(mktemp -d) || exit $?;
        trap "command rm -rf '$WORK'" EXIT;
        sed -e '$a\' "${NVM_DEFAULT_PACKAGE_FILE}" > "${WORK}/default-packages";
        while IFS=' ' read -r line; do
            [ -n "${line-}" ] || continue;
            [ "$(nvm_echo "${line}" | command cut -c1)" != "#" ] || continue;
            case $line in 
                *\ *)
                    nvm_err "Only one package per line is allowed in the ${NVM_DIR}/default-packages file. Please remove any lines with multiple space-separated values.";
                    return 1
                ;;
            esac;
            DEFAULT_PACKAGES="${DEFAULT_PACKAGES}${line} ";
        done < "${WORK}/default-packages";
        echo "${DEFAULT_PACKAGES}" | command xargs;
    fi
}
nvm_get_download_slug () 
{ 
    local FLAVOR;
    case "${1-}" in 
        node | iojs)
            FLAVOR="${1}"
        ;;
        *)
            nvm_err 'supported flavors: node, iojs';
            return 1
        ;;
    esac;
    local KIND;
    case "${2-}" in 
        binary | source)
            KIND="${2}"
        ;;
        *)
            nvm_err 'supported kinds: binary, source';
            return 2
        ;;
    esac;
    local VERSION;
    VERSION="${3-}";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local NVM_ARCH;
    NVM_ARCH="$(nvm_get_arch)";
    if ! nvm_is_merged_node_version "${VERSION}"; then
        if [ "${NVM_ARCH}" = 'armv6l' ] || [ "${NVM_ARCH}" = 'armv7l' ]; then
            NVM_ARCH="arm-pi";
        fi;
    fi;
    if [ "${KIND}" = 'binary' ]; then
        nvm_echo "${FLAVOR}-${VERSION}-${NVM_OS}-${NVM_ARCH}";
    else
        if [ "${KIND}" = 'source' ]; then
            nvm_echo "${FLAVOR}-${VERSION}";
        fi;
    fi
}
nvm_get_latest () 
{ 
    local NVM_LATEST_URL;
    local CURL_COMPRESSED_FLAG;
    if nvm_has "curl"; then
        if nvm_curl_use_compression; then
            CURL_COMPRESSED_FLAG="--compressed";
        fi;
        NVM_LATEST_URL="$(curl ${CURL_COMPRESSED_FLAG:-} -q -w "%{url_effective}\\n" -L -s -S http://latest.nvm.sh -o /dev/null)";
    else
        if nvm_has "wget"; then
            NVM_LATEST_URL="$(wget -q http://latest.nvm.sh --server-response -O /dev/null 2>&1 | command awk '/^  Location: /{DEST=$2} END{ print DEST }')";
        else
            nvm_err 'nvm needs curl or wget to proceed.';
            return 1;
        fi;
    fi;
    if [ -z "${NVM_LATEST_URL}" ]; then
        nvm_err "http://latest.nvm.sh did not redirect to the latest release on GitHub";
        return 2;
    fi;
    nvm_echo "${NVM_LATEST_URL##*/}"
}
nvm_get_make_jobs () 
{ 
    if nvm_is_natural_num "${1-}"; then
        NVM_MAKE_JOBS="$1";
        nvm_echo "number of \`make\` jobs: ${NVM_MAKE_JOBS}";
        return;
    else
        if [ -n "${1-}" ]; then
            unset NVM_MAKE_JOBS;
            nvm_err "$1 is invalid for number of \`make\` jobs, must be a natural number";
        fi;
    fi;
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local NVM_CPU_CORES;
    case "_${NVM_OS}" in 
        "_linux")
            NVM_CPU_CORES="$(nvm_grep -c -E '^processor.+: [0-9]+' /proc/cpuinfo)"
        ;;
        "_freebsd" | "_darwin" | "_openbsd")
            NVM_CPU_CORES="$(sysctl -n hw.ncpu)"
        ;;
        "_sunos")
            NVM_CPU_CORES="$(psrinfo | wc -l)"
        ;;
        "_aix")
            NVM_CPU_CORES="$(pmcycles -m | wc -l)"
        ;;
    esac;
    if ! nvm_is_natural_num "${NVM_CPU_CORES}"; then
        nvm_err 'Can not determine how many core(s) are available, running in single-threaded mode.';
        nvm_err 'Please report an issue on GitHub to help us make nvm run faster on your computer!';
        NVM_MAKE_JOBS=1;
    else
        nvm_echo "Detected that you have ${NVM_CPU_CORES} CPU core(s)";
        if [ "${NVM_CPU_CORES}" -gt 2 ]; then
            NVM_MAKE_JOBS=$((NVM_CPU_CORES - 1));
            nvm_echo "Running with ${NVM_MAKE_JOBS} threads to speed up the build";
        else
            NVM_MAKE_JOBS=1;
            nvm_echo 'Number of CPU core(s) less than or equal to 2, running in single-threaded mode';
        fi;
    fi
}
nvm_get_minor_version () 
{ 
    local VERSION;
    VERSION="$1";
    if [ -z "${VERSION}" ]; then
        nvm_err 'a version is required';
        return 1;
    fi;
    case "${VERSION}" in 
        v | .* | *..* | v*[!.0123456789]* | [!v]*[!.0123456789]* | [!v0123456789]* | v[!0123456789]*)
            nvm_err 'invalid version number';
            return 2
        ;;
    esac;
    local PREFIXED_VERSION;
    PREFIXED_VERSION="$(nvm_format_version "${VERSION}")";
    local MINOR;
    MINOR="$(nvm_echo "${PREFIXED_VERSION}" | nvm_grep -e '^v' | command cut -c2- | command cut -d . -f 1,2)";
    if [ -z "${MINOR}" ]; then
        nvm_err 'invalid version number! (please report this)';
        return 3;
    fi;
    nvm_echo "${MINOR}"
}
nvm_get_mirror () 
{ 
    case "${1}-${2}" in 
        node-std)
            nvm_echo "${NVM_NODEJS_ORG_MIRROR:-https://nodejs.org/dist}"
        ;;
        iojs-std)
            nvm_echo "${NVM_IOJS_ORG_MIRROR:-https://iojs.org/dist}"
        ;;
        *)
            nvm_err 'unknown type of node.js or io.js release';
            return 1
        ;;
    esac
}
nvm_get_os () 
{ 
    local NVM_UNAME;
    NVM_UNAME="$(command uname -a)";
    local NVM_OS;
    case "${NVM_UNAME}" in 
        Linux\ *)
            NVM_OS=linux
        ;;
        Darwin\ *)
            NVM_OS=darwin
        ;;
        SunOS\ *)
            NVM_OS=sunos
        ;;
        FreeBSD\ *)
            NVM_OS=freebsd
        ;;
        OpenBSD\ *)
            NVM_OS=openbsd
        ;;
        AIX\ *)
            NVM_OS=aix
        ;;
    esac;
    nvm_echo "${NVM_OS-}"
}
nvm_grep () 
{ 
    GREP_OPTIONS='' command grep "$@"
}
nvm_has () 
{ 
    type "${1-}" > /dev/null 2>&1
}
nvm_has_colors () 
{ 
    local NVM_NUM_COLORS;
    if nvm_has tput; then
        NVM_NUM_COLORS="$(tput -T "${TERM:-vt100}" colors)";
    fi;
    [ "${NVM_NUM_COLORS:--1}" -ge 8 ]
}
nvm_has_non_aliased () 
{ 
    nvm_has "${1-}" && ! nvm_is_alias "${1-}"
}
nvm_has_solaris_binary () 
{ 
    local VERSION=$1;
    if nvm_is_merged_node_version "${VERSION}"; then
        return 0;
    else
        if nvm_is_iojs_version "${VERSION}"; then
            nvm_iojs_version_has_solaris_binary "${VERSION}";
        else
            nvm_node_version_has_solaris_binary "${VERSION}";
        fi;
    fi
}
nvm_has_system_iojs () 
{ 
    [ "$(nvm deactivate >/dev/null 2>&1 && command -v iojs)" != '' ]
}
nvm_has_system_node () 
{ 
    [ "$(nvm deactivate >/dev/null 2>&1 && command -v node)" != '' ]
}
nvm_install_binary () 
{ 
    local FLAVOR;
    case "${1-}" in 
        node | iojs)
            FLAVOR="${1}"
        ;;
        *)
            nvm_err 'supported flavors: node, iojs';
            return 4
        ;;
    esac;
    local TYPE;
    TYPE="${2-}";
    local PREFIXED_VERSION;
    PREFIXED_VERSION="${3-}";
    if [ -z "${PREFIXED_VERSION}" ]; then
        nvm_err 'A version number is required.';
        return 3;
    fi;
    local nosource;
    nosource="${4-}";
    local VERSION;
    VERSION="$(nvm_strip_iojs_prefix "${PREFIXED_VERSION}")";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    if [ -z "${NVM_OS}" ]; then
        return 2;
    fi;
    local TARBALL;
    local TMPDIR;
    local PROGRESS_BAR;
    local NODE_OR_IOJS;
    if [ "${FLAVOR}" = 'node' ]; then
        NODE_OR_IOJS="${FLAVOR}";
    else
        if [ "${FLAVOR}" = 'iojs' ]; then
            NODE_OR_IOJS="io.js";
        fi;
    fi;
    if [ "${NVM_NO_PROGRESS-}" = "1" ]; then
        PROGRESS_BAR="-sS";
    else
        PROGRESS_BAR="--progress-bar";
    fi;
    nvm_echo "Downloading and installing ${NODE_OR_IOJS-} ${VERSION}...";
    TARBALL="$(PROGRESS_BAR="${PROGRESS_BAR}" nvm_download_artifact "${FLAVOR}" binary "${TYPE-}" "${VERSION}" | command tail -1)";
    if [ -f "${TARBALL}" ]; then
        TMPDIR="$(dirname "${TARBALL}")/files";
    fi;
    if nvm_install_binary_extract "${NVM_OS}" "${PREFIXED_VERSION}" "${VERSION}" "${TARBALL}" "${TMPDIR}"; then
        if [ -n "${ALIAS-}" ]; then
            nvm alias "${ALIAS}" "${provided_version}";
        fi;
        return 0;
    fi;
    if [ "${nosource-}" = '1' ]; then
        nvm_err 'Binary download failed. Download from source aborted.';
        return 0;
    fi;
    nvm_err 'Binary download failed, trying source.';
    if [ -n "${TMPDIR-}" ]; then
        command rm -rf "${TMPDIR}";
    fi;
    return 1
}
nvm_install_binary_extract () 
{ 
    if [ "$#" -ne 5 ]; then
        nvm_err 'nvm_install_binary_extract needs 5 parameters';
        return 1;
    fi;
    local NVM_OS;
    local PREFIXED_VERSION;
    local VERSION;
    local TARBALL;
    local TMPDIR;
    NVM_OS="${1}";
    PREFIXED_VERSION="${2}";
    VERSION="${3}";
    TARBALL="${4}";
    TMPDIR="${5}";
    local VERSION_PATH;
    [ -n "${TMPDIR-}" ] && command mkdir -p "${TMPDIR}" && VERSION_PATH="$(nvm_version_path "${PREFIXED_VERSION}")" || return 1;
    local tar_compression_flag;
    tar_compression_flag='z';
    if nvm_supports_xz "${VERSION}"; then
        tar_compression_flag='J';
    fi;
    local tar;
    if [ "${NVM_OS}" = 'aix' ]; then
        tar='gtar';
    else
        tar='tar';
    fi;
    command "${tar}" -x${tar_compression_flag}f "${TARBALL}" -C "${TMPDIR}" --strip-components 1 || return 1;
    command mkdir -p "${VERSION_PATH}" || return 1;
    command mv "${TMPDIR}/"* "${VERSION_PATH}" || return 1;
    command rm -rf "${TMPDIR}";
    return 0
}
nvm_install_default_packages () 
{ 
    nvm_echo "Installing default global packages from ${NVM_DIR}/default-packages...";
    nvm_echo "npm install -g --quiet $1";
    if ! nvm_echo "$1" | command xargs npm install -g --quiet; then
        nvm_err "Failed installing default packages. Please check if your default-packages file or a package in it has problems!";
        return 1;
    fi
}
nvm_install_latest_npm () 
{ 
    nvm_echo 'Attempting to upgrade to the latest working version of npm...';
    local NODE_VERSION;
    NODE_VERSION="$(nvm_strip_iojs_prefix "$(nvm_ls_current)")";
    if [ "${NODE_VERSION}" = 'system' ]; then
        NODE_VERSION="$(node --version)";
    else
        if [ "${NODE_VERSION}" = 'none' ]; then
            nvm_echo "Detected node version ${NODE_VERSION}, npm version v${NPM_VERSION}";
            NODE_VERSION='';
        fi;
    fi;
    if [ -z "${NODE_VERSION}" ]; then
        nvm_err 'Unable to obtain node version.';
        return 1;
    fi;
    local NPM_VERSION;
    NPM_VERSION="$(npm --version 2>/dev/null)";
    if [ -z "${NPM_VERSION}" ]; then
        nvm_err 'Unable to obtain npm version.';
        return 2;
    fi;
    local NVM_NPM_CMD;
    NVM_NPM_CMD='npm';
    if [ "${NVM_DEBUG-}" = 1 ]; then
        nvm_echo "Detected node version ${NODE_VERSION}, npm version v${NPM_VERSION}";
        NVM_NPM_CMD='nvm_echo npm';
    fi;
    local NVM_IS_0_6;
    NVM_IS_0_6=0;
    if nvm_version_greater_than_or_equal_to "${NODE_VERSION}" 0.6.0 && nvm_version_greater 0.7.0 "${NODE_VERSION}"; then
        NVM_IS_0_6=1;
    fi;
    local NVM_IS_0_9;
    NVM_IS_0_9=0;
    if nvm_version_greater_than_or_equal_to "${NODE_VERSION}" 0.9.0 && nvm_version_greater 0.10.0 "${NODE_VERSION}"; then
        NVM_IS_0_9=1;
    fi;
    if [ $NVM_IS_0_6 -eq 1 ]; then
        nvm_echo '* `node` v0.6.x can only upgrade to `npm` v1.3.x';
        $NVM_NPM_CMD install -g npm@1.3;
    else
        if [ $NVM_IS_0_9 -eq 0 ]; then
            if nvm_version_greater_than_or_equal_to "${NPM_VERSION}" 1.0.0 && nvm_version_greater 2.0.0 "${NPM_VERSION}"; then
                nvm_echo '* `npm` v1.x needs to first jump to `npm` v1.4.28 to be able to upgrade further';
                $NVM_NPM_CMD install -g npm@1.4.28;
            else
                if nvm_version_greater_than_or_equal_to "${NPM_VERSION}" 2.0.0 && nvm_version_greater 3.0.0 "${NPM_VERSION}"; then
                    nvm_echo '* `npm` v2.x needs to first jump to the latest v2 to be able to upgrade further';
                    $NVM_NPM_CMD install -g npm@2;
                fi;
            fi;
        fi;
    fi;
    if [ $NVM_IS_0_9 -eq 1 ] || [ $NVM_IS_0_6 -eq 1 ]; then
        nvm_echo '* node v0.6 and v0.9 are unable to upgrade further';
    else
        if nvm_version_greater 1.1.0 "${NODE_VERSION}"; then
            nvm_echo '* `npm` v4.5.x is the last version that works on `node` versions < v1.1.0';
            $NVM_NPM_CMD install -g npm@4.5;
        else
            if nvm_version_greater 4.0.0 "${NODE_VERSION}"; then
                nvm_echo '* `npm` v5 and higher do not work on `node` versions below v4.0.0';
                $NVM_NPM_CMD install -g npm@4;
            else
                if [ $NVM_IS_0_9 -eq 0 ] && [ $NVM_IS_0_6 -eq 0 ]; then
                    local NVM_IS_4_4_OR_BELOW;
                    NVM_IS_4_4_OR_BELOW=0;
                    if nvm_version_greater 4.5.0 "${NODE_VERSION}"; then
                        NVM_IS_4_4_OR_BELOW=1;
                    fi;
                    local NVM_IS_5_OR_ABOVE;
                    NVM_IS_5_OR_ABOVE=0;
                    if [ $NVM_IS_4_4_OR_BELOW -eq 0 ] && nvm_version_greater_than_or_equal_to "${NODE_VERSION}" 5.0.0; then
                        NVM_IS_5_OR_ABOVE=1;
                    fi;
                    local NVM_IS_6_OR_ABOVE;
                    NVM_IS_6_OR_ABOVE=0;
                    local NVM_IS_6_2_OR_ABOVE;
                    NVM_IS_6_2_OR_ABOVE=0;
                    if [ $NVM_IS_5_OR_ABOVE -eq 1 ] && nvm_version_greater_than_or_equal_to "${NODE_VERSION}" 6.0.0; then
                        NVM_IS_6_OR_ABOVE=1;
                        if nvm_version_greater_than_or_equal_to "${NODE_VERSION}" 6.2.0; then
                            NVM_IS_6_2_OR_ABOVE=1;
                        fi;
                    fi;
                    local NVM_IS_9_OR_ABOVE;
                    NVM_IS_9_OR_ABOVE=0;
                    local NVM_IS_9_3_OR_ABOVE;
                    NVM_IS_9_3_OR_ABOVE=0;
                    if [ $NVM_IS_6_2_OR_ABOVE -eq 1 ] && nvm_version_greater_than_or_equal_to "${NODE_VERSION}" 9.0.0; then
                        NVM_IS_9_OR_ABOVE=1;
                        if nvm_version_greater_than_or_equal_to "${NODE_VERSION}" 9.3.0; then
                            NVM_IS_9_3_OR_ABOVE=1;
                        fi;
                    fi;
                    local NVM_IS_10_OR_ABOVE;
                    NVM_IS_10_OR_ABOVE=0;
                    if [ $NVM_IS_9_3_OR_ABOVE -eq 1 ] && nvm_version_greater_than_or_equal_to "${NODE_VERSION}" 10.0.0; then
                        NVM_IS_10_OR_ABOVE=1;
                    fi;
                    if [ $NVM_IS_4_4_OR_BELOW -eq 1 ] || { 
                        [ $NVM_IS_5_OR_ABOVE -eq 1 ] && nvm_version_greater 5.10.0 "${NODE_VERSION}"
                    }; then
                        nvm_echo '* `npm` `v5.3.x` is the last version that works on `node` 4.x versions below v4.4, or 5.x versions below v5.10, due to `Buffer.alloc`';
                        $NVM_NPM_CMD install -g npm@5.3;
                    else
                        if [ $NVM_IS_4_4_OR_BELOW -eq 0 ] && nvm_version_greater 4.7.0 "${NODE_VERSION}"; then
                            nvm_echo '* `npm` `v5.4.1` is the last version that works on `node` `v4.5` and `v4.6`';
                            $NVM_NPM_CMD install -g npm@5.4.1;
                        else
                            if [ $NVM_IS_6_OR_ABOVE -eq 0 ]; then
                                nvm_echo '* `npm` `v5.x` is the last version that works on `node` below `v6.0.0`';
                                $NVM_NPM_CMD install -g npm@5;
                            else
                                if { 
                                    [ $NVM_IS_6_OR_ABOVE -eq 1 ] && [ $NVM_IS_6_2_OR_ABOVE -eq 0 ]
                                } || { 
                                    [ $NVM_IS_9_OR_ABOVE -eq 1 ] && [ $NVM_IS_9_3_OR_ABOVE -eq 0 ]
                                }; then
                                    nvm_echo '* `npm` `v6.9` is the last version that works on `node` `v6.0.x`, `v6.1.x`, `v9.0.x`, `v9.1.x`, or `v9.2.x`';
                                    $NVM_NPM_CMD install -g npm@6.9;
                                else
                                    if [ $NVM_IS_10_OR_ABOVE -eq 0 ]; then
                                        nvm_echo '* `npm` `v6.x` is the last version that works on `node` below `v10.0.0`';
                                        $NVM_NPM_CMD install -g npm@6;
                                    else
                                        nvm_echo '* Installing latest `npm`; if this does not work on your node version, please report a bug!';
                                        $NVM_NPM_CMD install -g npm;
                                    fi;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    nvm_echo "* npm upgraded to: v$(npm --version 2>/dev/null)"
}
nvm_install_npm_if_needed () 
{ 
    local VERSION;
    VERSION="$(nvm_ls_current)";
    if ! nvm_has "npm"; then
        nvm_echo 'Installing npm...';
        if nvm_version_greater 0.2.0 "${VERSION}"; then
            nvm_err 'npm requires node v0.2.3 or higher';
        else
            if nvm_version_greater_than_or_equal_to "${VERSION}" 0.2.0; then
                if nvm_version_greater 0.2.3 "${VERSION}"; then
                    nvm_err 'npm requires node v0.2.3 or higher';
                else
                    nvm_download -L https://npmjs.org/install.sh -o - | clean=yes npm_install=0.2.19 sh;
                fi;
            else
                nvm_download -L https://npmjs.org/install.sh -o - | clean=yes sh;
            fi;
        fi;
    fi;
    return $?
}
nvm_install_source () 
{ 
    local FLAVOR;
    case "${1-}" in 
        node | iojs)
            FLAVOR="${1}"
        ;;
        *)
            nvm_err 'supported flavors: node, iojs';
            return 4
        ;;
    esac;
    local TYPE;
    TYPE="${2-}";
    local PREFIXED_VERSION;
    PREFIXED_VERSION="${3-}";
    if [ -z "${PREFIXED_VERSION}" ]; then
        nvm_err 'A version number is required.';
        return 3;
    fi;
    local VERSION;
    VERSION="$(nvm_strip_iojs_prefix "${PREFIXED_VERSION}")";
    local NVM_MAKE_JOBS;
    NVM_MAKE_JOBS="${4-}";
    local ADDITIONAL_PARAMETERS;
    ADDITIONAL_PARAMETERS="${5-}";
    local NVM_ARCH;
    NVM_ARCH="$(nvm_get_arch)";
    if [ "${NVM_ARCH}" = 'armv6l' ] || [ "${NVM_ARCH}" = 'armv7l' ]; then
        if [ -n "${ADDITIONAL_PARAMETERS}" ]; then
            ADDITIONAL_PARAMETERS="--without-snapshot ${ADDITIONAL_PARAMETERS}";
        else
            ADDITIONAL_PARAMETERS='--without-snapshot';
        fi;
    fi;
    if [ -n "${ADDITIONAL_PARAMETERS}" ]; then
        nvm_echo "Additional options while compiling: ${ADDITIONAL_PARAMETERS}";
    fi;
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local make;
    make='make';
    local MAKE_CXX;
    case "${NVM_OS}" in 
        'freebsd')
            make='gmake';
            MAKE_CXX="CC=${CC:-cc} CXX=${CXX:-c++}"
        ;;
        'darwin')
            MAKE_CXX="CC=${CC:-cc} CXX=${CXX:-c++}"
        ;;
        'aix')
            make='gmake'
        ;;
    esac;
    if nvm_has "clang++" && nvm_has "clang" && nvm_version_greater_than_or_equal_to "$(nvm_clang_version)" 3.5; then
        if [ -z "${CC-}" ] || [ -z "${CXX-}" ]; then
            nvm_echo "Clang v3.5+ detected! CC or CXX not specified, will use Clang as C/C++ compiler!";
            MAKE_CXX="CC=${CC:-cc} CXX=${CXX:-c++}";
        fi;
    fi;
    local tar_compression_flag;
    tar_compression_flag='z';
    if nvm_supports_xz "${VERSION}"; then
        tar_compression_flag='J';
    fi;
    local tar;
    tar='tar';
    if [ "${NVM_OS}" = 'aix' ]; then
        tar='gtar';
    fi;
    local TARBALL;
    local TMPDIR;
    local VERSION_PATH;
    if [ "${NVM_NO_PROGRESS-}" = "1" ]; then
        PROGRESS_BAR="-sS";
    else
        PROGRESS_BAR="--progress-bar";
    fi;
    nvm_is_zsh && setopt local_options shwordsplit;
    TARBALL="$(PROGRESS_BAR="${PROGRESS_BAR}" nvm_download_artifact "${FLAVOR}" source "${TYPE}" "${VERSION}" | command tail -1)" && [ -f "${TARBALL}" ] && TMPDIR="$(dirname "${TARBALL}")/files" && if ! ( command mkdir -p "${TMPDIR}" && command "${tar}" -x${tar_compression_flag}f "${TARBALL}" -C "${TMPDIR}" --strip-components 1 && VERSION_PATH="$(nvm_version_path "${PREFIXED_VERSION}")" && nvm_cd "${TMPDIR}" && nvm_echo '$>'./configure --prefix="${VERSION_PATH}" $ADDITIONAL_PARAMETERS'<' && ./configure --prefix="${VERSION_PATH}" $ADDITIONAL_PARAMETERS && $make -j "${NVM_MAKE_JOBS}" ${MAKE_CXX-} && command rm -f "${VERSION_PATH}" 2> /dev/null && $make -j "${NVM_MAKE_JOBS}" ${MAKE_CXX-} install ); then
        nvm_err "nvm: install ${VERSION} failed!";
        command rm -rf "${TMPDIR-}";
        return 1;
    fi
}
nvm_iojs_prefix () 
{ 
    nvm_echo 'iojs'
}
nvm_iojs_version_has_solaris_binary () 
{ 
    local IOJS_VERSION;
    IOJS_VERSION="$1";
    local STRIPPED_IOJS_VERSION;
    STRIPPED_IOJS_VERSION="$(nvm_strip_iojs_prefix "${IOJS_VERSION}")";
    if [ "_${STRIPPED_IOJS_VERSION}" = "${IOJS_VERSION}" ]; then
        return 1;
    fi;
    nvm_version_greater_than_or_equal_to "${STRIPPED_IOJS_VERSION}" v3.3.1
}
nvm_is_alias () 
{ 
    \alias "${1-}" > /dev/null 2>&1
}
nvm_is_iojs_version () 
{ 
    case "${1-}" in 
        iojs-*)
            return 0
        ;;
    esac;
    return 1
}
nvm_is_merged_node_version () 
{ 
    nvm_version_greater_than_or_equal_to "$1" v4.0.0
}
nvm_is_natural_num () 
{ 
    if [ -z "$1" ]; then
        return 4;
    fi;
    case "$1" in 
        0)
            return 1
        ;;
        -*)
            return 3
        ;;
        *)
            [ "$1" -eq "$1" ] 2> /dev/null
        ;;
    esac
}
nvm_is_valid_version () 
{ 
    if nvm_validate_implicit_alias "${1-}" 2> /dev/null; then
        return 0;
    fi;
    case "${1-}" in 
        "$(nvm_iojs_prefix)" | "$(nvm_node_prefix)")
            return 0
        ;;
        *)
            local VERSION;
            VERSION="$(nvm_strip_iojs_prefix "${1-}")";
            nvm_version_greater_than_or_equal_to "${VERSION}" 0
        ;;
    esac
}
nvm_is_version_installed () 
{ 
    [ -n "${1-}" ] && [ -x "$(nvm_version_path "$1" 2>/dev/null)"/bin/node ]
}
nvm_is_zsh () 
{ 
    [ -n "${ZSH_VERSION-}" ]
}
nvm_list_aliases () 
{ 
    local ALIAS;
    ALIAS="${1-}";
    local NVM_CURRENT;
    NVM_CURRENT="$(nvm_ls_current)";
    local NVM_ALIAS_DIR;
    NVM_ALIAS_DIR="$(nvm_alias_path)";
    command mkdir -p "${NVM_ALIAS_DIR}/lts";
    ( local ALIAS_PATH;
    for ALIAS_PATH in "${NVM_ALIAS_DIR}/${ALIAS}"*;
    do
        NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_CURRENT="${NVM_CURRENT}" nvm_print_alias_path "${NVM_ALIAS_DIR}" "${ALIAS_PATH}" &
    done;
    wait ) | sort;
    ( local ALIAS_NAME;
    for ALIAS_NAME in "$(nvm_node_prefix)" "stable" "unstable";
    do
        { 
            if [ ! -f "${NVM_ALIAS_DIR}/${ALIAS_NAME}" ] && { 
                [ -z "${ALIAS}" ] || [ "${ALIAS_NAME}" = "${ALIAS}" ]
            }; then
                NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_CURRENT="${NVM_CURRENT}" nvm_print_default_alias "${ALIAS_NAME}";
            fi
        } &
    done;
    wait;
    ALIAS_NAME="$(nvm_iojs_prefix)";
    if [ ! -f "${NVM_ALIAS_DIR}/${ALIAS_NAME}" ] && { 
        [ -z "${ALIAS}" ] || [ "${ALIAS_NAME}" = "${ALIAS}" ]
    }; then
        NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_CURRENT="${NVM_CURRENT}" nvm_print_default_alias "${ALIAS_NAME}";
    fi ) | sort;
    ( local LTS_ALIAS;
    for ALIAS_PATH in "${NVM_ALIAS_DIR}/lts/${ALIAS}"*;
    do
        { 
            LTS_ALIAS="$(NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_LTS=true nvm_print_alias_path "${NVM_ALIAS_DIR}" "${ALIAS_PATH}")";
            if [ -n "${LTS_ALIAS}" ]; then
                nvm_echo "${LTS_ALIAS}";
            fi
        } &
    done;
    wait ) | sort;
    return
}
nvm_ls () 
{ 
    local PATTERN;
    PATTERN="${1-}";
    local VERSIONS;
    VERSIONS='';
    if [ "${PATTERN}" = 'current' ]; then
        nvm_ls_current;
        return;
    fi;
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    local NVM_VERSION_DIR_IOJS;
    NVM_VERSION_DIR_IOJS="$(nvm_version_dir "${NVM_IOJS_PREFIX}")";
    local NVM_VERSION_DIR_NEW;
    NVM_VERSION_DIR_NEW="$(nvm_version_dir new)";
    local NVM_VERSION_DIR_OLD;
    NVM_VERSION_DIR_OLD="$(nvm_version_dir old)";
    case "${PATTERN}" in 
        "${NVM_IOJS_PREFIX}" | "${NVM_NODE_PREFIX}")
            PATTERN="${PATTERN}-"
        ;;
        *)
            if nvm_resolve_local_alias "${PATTERN}"; then
                return;
            fi;
            PATTERN="$(nvm_ensure_version_prefix "${PATTERN}")"
        ;;
    esac;
    if [ "${PATTERN}" = 'N/A' ]; then
        return;
    fi;
    local NVM_PATTERN_STARTS_WITH_V;
    case $PATTERN in 
        v*)
            NVM_PATTERN_STARTS_WITH_V=true
        ;;
        *)
            NVM_PATTERN_STARTS_WITH_V=false
        ;;
    esac;
    if [ $NVM_PATTERN_STARTS_WITH_V = true ] && [ "_$(nvm_num_version_groups "${PATTERN}")" = "_3" ]; then
        if nvm_is_version_installed "${PATTERN}"; then
            VERSIONS="${PATTERN}";
        else
            if nvm_is_version_installed "$(nvm_add_iojs_prefix "${PATTERN}")"; then
                VERSIONS="$(nvm_add_iojs_prefix "${PATTERN}")";
            fi;
        fi;
    else
        case "${PATTERN}" in 
            "${NVM_IOJS_PREFIX}-" | "${NVM_NODE_PREFIX}-" | "system")

            ;;
            *)
                local NUM_VERSION_GROUPS;
                NUM_VERSION_GROUPS="$(nvm_num_version_groups "${PATTERN}")";
                if [ "${NUM_VERSION_GROUPS}" = "2" ] || [ "${NUM_VERSION_GROUPS}" = "1" ]; then
                    PATTERN="${PATTERN%.}.";
                fi
            ;;
        esac;
        nvm_is_zsh && setopt local_options shwordsplit;
        nvm_is_zsh && unsetopt local_options markdirs;
        local NVM_DIRS_TO_SEARCH1;
        NVM_DIRS_TO_SEARCH1='';
        local NVM_DIRS_TO_SEARCH2;
        NVM_DIRS_TO_SEARCH2='';
        local NVM_DIRS_TO_SEARCH3;
        NVM_DIRS_TO_SEARCH3='';
        local NVM_ADD_SYSTEM;
        NVM_ADD_SYSTEM=false;
        if nvm_is_iojs_version "${PATTERN}"; then
            NVM_DIRS_TO_SEARCH1="${NVM_VERSION_DIR_IOJS}";
            PATTERN="$(nvm_strip_iojs_prefix "${PATTERN}")";
            if nvm_has_system_iojs; then
                NVM_ADD_SYSTEM=true;
            fi;
        else
            if [ "${PATTERN}" = "${NVM_NODE_PREFIX}-" ]; then
                NVM_DIRS_TO_SEARCH1="${NVM_VERSION_DIR_OLD}";
                NVM_DIRS_TO_SEARCH2="${NVM_VERSION_DIR_NEW}";
                PATTERN='';
                if nvm_has_system_node; then
                    NVM_ADD_SYSTEM=true;
                fi;
            else
                NVM_DIRS_TO_SEARCH1="${NVM_VERSION_DIR_OLD}";
                NVM_DIRS_TO_SEARCH2="${NVM_VERSION_DIR_NEW}";
                NVM_DIRS_TO_SEARCH3="${NVM_VERSION_DIR_IOJS}";
                if nvm_has_system_iojs || nvm_has_system_node; then
                    NVM_ADD_SYSTEM=true;
                fi;
            fi;
        fi;
        if ! [ -d "${NVM_DIRS_TO_SEARCH1}" ] || ! ( command ls -1qA "${NVM_DIRS_TO_SEARCH1}" | nvm_grep -q . ); then
            NVM_DIRS_TO_SEARCH1='';
        fi;
        if ! [ -d "${NVM_DIRS_TO_SEARCH2}" ] || ! ( command ls -1qA "${NVM_DIRS_TO_SEARCH2}" | nvm_grep -q . ); then
            NVM_DIRS_TO_SEARCH2="${NVM_DIRS_TO_SEARCH1}";
        fi;
        if ! [ -d "${NVM_DIRS_TO_SEARCH3}" ] || ! ( command ls -1qA "${NVM_DIRS_TO_SEARCH3}" | nvm_grep -q . ); then
            NVM_DIRS_TO_SEARCH3="${NVM_DIRS_TO_SEARCH2}";
        fi;
        local SEARCH_PATTERN;
        if [ -z "${PATTERN}" ]; then
            PATTERN='v';
            SEARCH_PATTERN='.*';
        else
            SEARCH_PATTERN="$(nvm_echo "${PATTERN}" | command sed 's#\.#\\\.#g;')";
        fi;
        if [ -n "${NVM_DIRS_TO_SEARCH1}${NVM_DIRS_TO_SEARCH2}${NVM_DIRS_TO_SEARCH3}" ]; then
            VERSIONS="$(command find "${NVM_DIRS_TO_SEARCH1}"/* "${NVM_DIRS_TO_SEARCH2}"/* "${NVM_DIRS_TO_SEARCH3}"/* -name . -o -type d -prune -o -path "${PATTERN}*"         | command sed -e "
            s#${NVM_VERSION_DIR_IOJS}/#versions/${NVM_IOJS_PREFIX}/#;
            s#^${NVM_DIR}/##;
            \\#^[^v]# d;
            \\#^versions\$# d;
            s#^versions/##;
            s#^v#${NVM_NODE_PREFIX}/v#;
            \\#${SEARCH_PATTERN}# !d;
          "           -e 's#^\([^/]\{1,\}\)/\(.*\)$#\2.\1#;'         | command sort -t. -u -k 1.2,1n -k 2,2n -k 3,3n         | command sed -e 's#\(.*\)\.\([^\.]\{1,\}\)$#\2-\1#;'                       -e "s#^${NVM_NODE_PREFIX}-##;"       )";
        fi;
    fi;
    if [ "${NVM_ADD_SYSTEM-}" = true ]; then
        if [ -z "${PATTERN}" ] || [ "${PATTERN}" = 'v' ]; then
            VERSIONS="${VERSIONS}$(command printf '\n%s' 'system')";
        else
            if [ "${PATTERN}" = 'system' ]; then
                VERSIONS="$(command printf '%s' 'system')";
            fi;
        fi;
    fi;
    if [ -z "${VERSIONS}" ]; then
        nvm_echo 'N/A';
        return 3;
    fi;
    nvm_echo "${VERSIONS}"
}
nvm_ls_current () 
{ 
    local NVM_LS_CURRENT_NODE_PATH;
    if ! NVM_LS_CURRENT_NODE_PATH="$(command which node 2>/dev/null)"; then
        nvm_echo 'none';
    else
        if nvm_tree_contains_path "$(nvm_version_dir iojs)" "${NVM_LS_CURRENT_NODE_PATH}"; then
            nvm_add_iojs_prefix "$(iojs --version 2>/dev/null)";
        else
            if nvm_tree_contains_path "${NVM_DIR}" "${NVM_LS_CURRENT_NODE_PATH}"; then
                local VERSION;
                VERSION="$(node --version 2>/dev/null)";
                if [ "${VERSION}" = "v0.6.21-pre" ]; then
                    nvm_echo 'v0.6.21';
                else
                    nvm_echo "${VERSION}";
                fi;
            else
                nvm_echo 'system';
            fi;
        fi;
    fi
}
nvm_ls_remote () 
{ 
    local PATTERN;
    PATTERN="${1-}";
    if nvm_validate_implicit_alias "${PATTERN}" 2> /dev/null; then
        local IMPLICIT;
        IMPLICIT="$(nvm_print_implicit_alias remote "${PATTERN}")";
        if [ -z "${IMPLICIT-}" ] || [ "${IMPLICIT}" = 'N/A' ]; then
            nvm_echo "N/A";
            return 3;
        fi;
        PATTERN="$(NVM_LTS="${NVM_LTS-}" nvm_ls_remote "${IMPLICIT}" | command tail -1 | command awk '{ print $1 }')";
    else
        if [ -n "${PATTERN}" ]; then
            PATTERN="$(nvm_ensure_version_prefix "${PATTERN}")";
        else
            PATTERN=".*";
        fi;
    fi;
    NVM_LTS="${NVM_LTS-}" nvm_ls_remote_index_tab node std "${PATTERN}"
}
nvm_ls_remote_index_tab () 
{ 
    local LTS;
    LTS="${NVM_LTS-}";
    if [ "$#" -lt 3 ]; then
        nvm_err 'not enough arguments';
        return 5;
    fi;
    local FLAVOR;
    FLAVOR="${1-}";
    local TYPE;
    TYPE="${2-}";
    local MIRROR;
    MIRROR="$(nvm_get_mirror "${FLAVOR}" "${TYPE}")";
    if [ -z "${MIRROR}" ]; then
        return 3;
    fi;
    local PREFIX;
    PREFIX='';
    case "${FLAVOR}-${TYPE}" in 
        iojs-std)
            PREFIX="$(nvm_iojs_prefix)-"
        ;;
        node-std)
            PREFIX=''
        ;;
        iojs-*)
            nvm_err 'unknown type of io.js release';
            return 4
        ;;
        *)
            nvm_err 'unknown type of node.js release';
            return 4
        ;;
    esac;
    local SORT_COMMAND;
    SORT_COMMAND='command sort';
    case "${FLAVOR}" in 
        node)
            SORT_COMMAND='command sort -t. -u -k 1.2,1n -k 2,2n -k 3,3n'
        ;;
    esac;
    local PATTERN;
    PATTERN="${3-}";
    if [ "${PATTERN#"${PATTERN%?}"}" = '.' ]; then
        PATTERN="${PATTERN%.}";
    fi;
    local VERSIONS;
    if [ -n "${PATTERN}" ] && [ "${PATTERN}" != '*' ]; then
        if [ "${FLAVOR}" = 'iojs' ]; then
            PATTERN="$(nvm_ensure_version_prefix "$(nvm_strip_iojs_prefix "${PATTERN}")")";
        else
            PATTERN="$(nvm_ensure_version_prefix "${PATTERN}")";
        fi;
    else
        unset PATTERN;
    fi;
    nvm_is_zsh && setopt local_options shwordsplit;
    local VERSION_LIST;
    VERSION_LIST="$(nvm_download -L -s "${MIRROR}/index.tab" -o -     | command sed "
        1d;
        s/^/${PREFIX}/;
      "   )";
    local LTS_ALIAS;
    local LTS_VERSION;
    command mkdir -p "$(nvm_alias_path)/lts";
    nvm_echo "${VERSION_LIST}" | command awk '{
        if ($10 ~ /^\-?$/) { next }
        if ($10 && !a[tolower($10)]++) {
          if (alias) { print alias, version }
          alias_name = "lts/" tolower($10)
          if (!alias) { print "lts/*", alias_name }
          alias = alias_name
          version = $1
        }
      }
      END {
        if (alias) {
          print alias, version
        }
      }' | while read -r LTS_ALIAS_LINE; do
        LTS_ALIAS="${LTS_ALIAS_LINE%% *}";
        LTS_VERSION="${LTS_ALIAS_LINE#* }";
        nvm_make_alias "${LTS_ALIAS}" "${LTS_VERSION}" > /dev/null 2>&1;
    done;
    VERSIONS="$({ command awk -v lts="${LTS-}" '{
        if (!$1) { next }
        if (lts && $10 ~ /^\-?$/) { next }
        if (lts && lts != "*" && tolower($10) !~ tolower(lts)) { next }
        if ($10 !~ /^\-?$/) {
          if ($10 && $10 != prev) {
            print $1, $10, "*"
          } else {
            print $1, $10
          }
        } else {
          print $1
        }
        prev=$10;
      }'     | nvm_grep -w "${PATTERN:-.*}"     | $SORT_COMMAND; } << EOF
$VERSION_LIST
EOF
)";
    if [ -z "${VERSIONS}" ]; then
        nvm_echo 'N/A';
        return 3;
    fi;
    nvm_echo "${VERSIONS}"
}
nvm_ls_remote_iojs () 
{ 
    NVM_LTS="${NVM_LTS-}" nvm_ls_remote_index_tab iojs std "${1-}"
}
nvm_make_alias () 
{ 
    local ALIAS;
    ALIAS="${1-}";
    if [ -z "${ALIAS}" ]; then
        nvm_err "an alias name is required";
        return 1;
    fi;
    local VERSION;
    VERSION="${2-}";
    if [ -z "${VERSION}" ]; then
        nvm_err "an alias target version is required";
        return 2;
    fi;
    nvm_echo "${VERSION}" | tee "$(nvm_alias_path)/${ALIAS}" > /dev/null
}
nvm_match_version () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local PROVIDED_VERSION;
    PROVIDED_VERSION="$1";
    case "_${PROVIDED_VERSION}" in 
        "_${NVM_IOJS_PREFIX}" | '_io.js')
            nvm_version "${NVM_IOJS_PREFIX}"
        ;;
        '_system')
            nvm_echo 'system'
        ;;
        *)
            nvm_version "${PROVIDED_VERSION}"
        ;;
    esac
}
nvm_node_prefix () 
{ 
    nvm_echo 'node'
}
nvm_node_version_has_solaris_binary () 
{ 
    local NODE_VERSION;
    NODE_VERSION="$1";
    local STRIPPED_IOJS_VERSION;
    STRIPPED_IOJS_VERSION="$(nvm_strip_iojs_prefix "${NODE_VERSION}")";
    if [ "_${STRIPPED_IOJS_VERSION}" != "_${NODE_VERSION}" ]; then
        return 1;
    fi;
    nvm_version_greater_than_or_equal_to "${NODE_VERSION}" v0.8.6 && ! nvm_version_greater_than_or_equal_to "${NODE_VERSION}" v1.0.0
}
nvm_normalize_version () 
{ 
    command awk 'BEGIN {
    split(ARGV[1], a, /\./);
    printf "%d%06d%06d\n", a[1], a[2], a[3];
    exit;
  }' "${1#v}"
}
nvm_npm_global_modules () 
{ 
    local NPMLIST;
    local VERSION;
    VERSION="$1";
    NPMLIST=$(nvm use "${VERSION}" >/dev/null && npm list -g --depth=0 2>/dev/null | command sed 1,1d | nvm_grep -v 'UNMET PEER DEPENDENCY');
    local INSTALLS;
    INSTALLS=$(nvm_echo "${NPMLIST}" | command sed -e '/ -> / d' -e '/\(empty\)/ d' -e 's/^.* \(.*@[^ ]*\).*/\1/' -e '/^npm@[^ ]*.*$/ d' | command xargs);
    local LINKS;
    LINKS="$(nvm_echo "${NPMLIST}" | command sed -n 's/.* -> \(.*\)/\1/ p')";
    nvm_echo "${INSTALLS} //// ${LINKS}"
}
nvm_npmrc_bad_news_bears () 
{ 
    local NVM_NPMRC;
    NVM_NPMRC="${1-}";
    if [ -n "${NVM_NPMRC}" ] && [ -f "${NVM_NPMRC}" ] && nvm_grep -Ee '^(prefix|globalconfig) *=' < "${NVM_NPMRC}" > /dev/null; then
        return 0;
    fi;
    return 1
}
nvm_num_version_groups () 
{ 
    local VERSION;
    VERSION="${1-}";
    VERSION="${VERSION#v}";
    VERSION="${VERSION%.}";
    if [ -z "${VERSION}" ]; then
        nvm_echo "0";
        return;
    fi;
    local NVM_NUM_DOTS;
    NVM_NUM_DOTS=$(nvm_echo "${VERSION}" | command sed -e 's/[^\.]//g');
    local NVM_NUM_GROUPS;
    NVM_NUM_GROUPS=".${NVM_NUM_DOTS}";
    nvm_echo "${#NVM_NUM_GROUPS}"
}
nvm_print_alias_path () 
{ 
    local NVM_ALIAS_DIR;
    NVM_ALIAS_DIR="${1-}";
    if [ -z "${NVM_ALIAS_DIR}" ]; then
        nvm_err 'An alias dir is required.';
        return 1;
    fi;
    local ALIAS_PATH;
    ALIAS_PATH="${2-}";
    if [ -z "${ALIAS_PATH}" ]; then
        nvm_err 'An alias path is required.';
        return 2;
    fi;
    local ALIAS;
    ALIAS="${ALIAS_PATH##${NVM_ALIAS_DIR}\/}";
    local DEST;
    DEST="$(nvm_alias "${ALIAS}" 2>/dev/null)" || :;
    if [ -n "${DEST}" ]; then
        NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_LTS="${NVM_LTS-}" DEFAULT=false nvm_print_formatted_alias "${ALIAS}" "${DEST}";
    fi
}
nvm_print_color_code () 
{ 
    case "${1-}" in 
        'r')
            nvm_echo '0;31m'
        ;;
        'R')
            nvm_echo '1;31m'
        ;;
        'g')
            nvm_echo '0;32m'
        ;;
        'G')
            nvm_echo '1;32m'
        ;;
        'b')
            nvm_echo '0;34m'
        ;;
        'B')
            nvm_echo '1;34m'
        ;;
        'c')
            nvm_echo '0;36m'
        ;;
        'C')
            nvm_echo '1;36m'
        ;;
        'm')
            nvm_echo '0;35m'
        ;;
        'M')
            nvm_echo '1;35m'
        ;;
        'y')
            nvm_echo '0;33m'
        ;;
        'Y')
            nvm_echo '1;33m'
        ;;
        'k')
            nvm_echo '0;30m'
        ;;
        'K')
            nvm_echo '1;30m'
        ;;
        'e')
            nvm_echo '0;37m'
        ;;
        'W')
            nvm_echo '1;37m'
        ;;
        *)
            nvm_err 'Invalid color code';
            return 1
        ;;
    esac
}
nvm_print_default_alias () 
{ 
    local ALIAS;
    ALIAS="${1-}";
    if [ -z "${ALIAS}" ]; then
        nvm_err 'A default alias is required.';
        return 1;
    fi;
    local DEST;
    DEST="$(nvm_print_implicit_alias local "${ALIAS}")";
    if [ -n "${DEST}" ]; then
        NVM_NO_COLORS="${NVM_NO_COLORS-}" DEFAULT=true nvm_print_formatted_alias "${ALIAS}" "${DEST}";
    fi
}
nvm_print_formatted_alias () 
{ 
    local ALIAS;
    ALIAS="${1-}";
    local DEST;
    DEST="${2-}";
    local VERSION;
    VERSION="${3-}";
    if [ -z "${VERSION}" ]; then
        VERSION="$(nvm_version "${DEST}")" || :;
    fi;
    local VERSION_FORMAT;
    local ALIAS_FORMAT;
    local DEST_FORMAT;
    local INSTALLED_COLOR;
    local SYSTEM_COLOR;
    local CURRENT_COLOR;
    local NOT_INSTALLED_COLOR;
    local DEFAULT_COLOR;
    local LTS_COLOR;
    INSTALLED_COLOR=$(nvm_get_colors 1);
    SYSTEM_COLOR=$(nvm_get_colors 2);
    CURRENT_COLOR=$(nvm_get_colors 3);
    NOT_INSTALLED_COLOR=$(nvm_get_colors 4);
    DEFAULT_COLOR=$(nvm_get_colors 5);
    LTS_COLOR=$(nvm_get_colors 6);
    ALIAS_FORMAT='%s';
    DEST_FORMAT='%s';
    VERSION_FORMAT='%s';
    local NEWLINE;
    NEWLINE='\n';
    if [ "_${DEFAULT}" = '_true' ]; then
        NEWLINE=' (default)\n';
    fi;
    local ARROW;
    ARROW='->';
    if [ -z "${NVM_NO_COLORS}" ] && nvm_has_colors; then
        ARROW='\033[0;90m->\033[0m';
        if [ "_${DEFAULT}" = '_true' ]; then
            NEWLINE=" \033[${DEFAULT_COLOR}(default)\033[0m\n";
        fi;
        if [ "_${VERSION}" = "_${NVM_CURRENT-}" ]; then
            ALIAS_FORMAT="\033[${CURRENT_COLOR}%s\033[0m";
            DEST_FORMAT="\033[${CURRENT_COLOR}%s\033[0m";
            VERSION_FORMAT="\033[${CURRENT_COLOR}%s\033[0m";
        else
            if nvm_is_version_installed "${VERSION}"; then
                ALIAS_FORMAT="\033[${INSTALLED_COLOR}%s\033[0m";
                DEST_FORMAT="\033[${INSTALLED_COLOR}%s\033[0m";
                VERSION_FORMAT="\033[${INSTALLED_COLOR}%s\033[0m";
            else
                if [ "${VERSION}" = '∞' ] || [ "${VERSION}" = 'N/A' ]; then
                    ALIAS_FORMAT="\033[${NOT_INSTALLED_COLOR}%s\033[0m";
                    DEST_FORMAT="\033[${NOT_INSTALLED_COLOR}%s\033[0m";
                    VERSION_FORMAT="\033[${NOT_INSTALLED_COLOR}%s\033[0m";
                fi;
            fi;
        fi;
        if [ "_${NVM_LTS-}" = '_true' ]; then
            ALIAS_FORMAT="\033[${LTS_COLOR}%s\033[0m";
        fi;
        if [ "_${DEST%/*}" = "_lts" ]; then
            DEST_FORMAT="\033[${LTS_COLOR}%s\033[0m";
        fi;
    else
        if [ "_${VERSION}" != '_∞' ] && [ "_${VERSION}" != '_N/A' ]; then
            VERSION_FORMAT='%s *';
        fi;
    fi;
    if [ "${DEST}" = "${VERSION}" ]; then
        command printf -- "${ALIAS_FORMAT} ${ARROW} ${VERSION_FORMAT}${NEWLINE}" "${ALIAS}" "${DEST}";
    else
        command printf -- "${ALIAS_FORMAT} ${ARROW} ${DEST_FORMAT} (${ARROW} ${VERSION_FORMAT})${NEWLINE}" "${ALIAS}" "${DEST}" "${VERSION}";
    fi
}
nvm_print_implicit_alias () 
{ 
    if [ "_$1" != "_local" ] && [ "_$1" != "_remote" ]; then
        nvm_err "nvm_print_implicit_alias must be specified with local or remote as the first argument.";
        return 1;
    fi;
    local NVM_IMPLICIT;
    NVM_IMPLICIT="$2";
    if ! nvm_validate_implicit_alias "${NVM_IMPLICIT}"; then
        return 2;
    fi;
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    local NVM_COMMAND;
    local NVM_ADD_PREFIX_COMMAND;
    local LAST_TWO;
    case "${NVM_IMPLICIT}" in 
        "${NVM_IOJS_PREFIX}")
            NVM_COMMAND="nvm_ls_remote_iojs";
            NVM_ADD_PREFIX_COMMAND="nvm_add_iojs_prefix";
            if [ "_$1" = "_local" ]; then
                NVM_COMMAND="nvm_ls ${NVM_IMPLICIT}";
            fi;
            nvm_is_zsh && setopt local_options shwordsplit;
            local NVM_IOJS_VERSION;
            local EXIT_CODE;
            NVM_IOJS_VERSION="$(${NVM_COMMAND})" && :;
            EXIT_CODE="$?";
            if [ "_${EXIT_CODE}" = "_0" ]; then
                NVM_IOJS_VERSION="$(nvm_echo "${NVM_IOJS_VERSION}" | command sed "s/^${NVM_IMPLICIT}-//" | nvm_grep -e '^v' | command cut -c2- | command cut -d . -f 1,2 | uniq | command tail -1)";
            fi;
            if [ "_$NVM_IOJS_VERSION" = "_N/A" ]; then
                nvm_echo 'N/A';
            else
                ${NVM_ADD_PREFIX_COMMAND} "${NVM_IOJS_VERSION}";
            fi;
            return $EXIT_CODE
        ;;
        "${NVM_NODE_PREFIX}")
            nvm_echo 'stable';
            return
        ;;
        *)
            NVM_COMMAND="nvm_ls_remote";
            if [ "_$1" = "_local" ]; then
                NVM_COMMAND="nvm_ls node";
            fi;
            nvm_is_zsh && setopt local_options shwordsplit;
            LAST_TWO=$($NVM_COMMAND | nvm_grep -e '^v' | command cut -c2- | command cut -d . -f 1,2 | uniq)
        ;;
    esac;
    local MINOR;
    local STABLE;
    local UNSTABLE;
    local MOD;
    local NORMALIZED_VERSION;
    nvm_is_zsh && setopt local_options shwordsplit;
    for MINOR in $LAST_TWO;
    do
        NORMALIZED_VERSION="$(nvm_normalize_version "$MINOR")";
        if [ "_0${NORMALIZED_VERSION#?}" != "_$NORMALIZED_VERSION" ]; then
            STABLE="$MINOR";
        else
            MOD="$(awk 'BEGIN { print int(ARGV[1] / 1000000) % 2 ; exit(0) }' "${NORMALIZED_VERSION}")";
            if [ "${MOD}" -eq 0 ]; then
                STABLE="${MINOR}";
            else
                if [ "${MOD}" -eq 1 ]; then
                    UNSTABLE="${MINOR}";
                fi;
            fi;
        fi;
    done;
    if [ "_$2" = '_stable' ]; then
        nvm_echo "${STABLE}";
    else
        if [ "_$2" = '_unstable' ]; then
            nvm_echo "${UNSTABLE:-"N/A"}";
        fi;
    fi
}
nvm_print_npm_version () 
{ 
    if nvm_has "npm"; then
        command printf " (npm v$(npm --version 2>/dev/null))";
    fi
}
nvm_print_versions () 
{ 
    local VERSION;
    local LTS;
    local FORMAT;
    local NVM_CURRENT;
    local NVM_LATEST_LTS_COLOR;
    local NVM_OLD_LTS_COLOR;
    local INSTALLED_COLOR;
    local SYSTEM_COLOR;
    local CURRENT_COLOR;
    local NOT_INSTALLED_COLOR;
    local DEFAULT_COLOR;
    local LTS_COLOR;
    INSTALLED_COLOR=$(nvm_get_colors 1);
    SYSTEM_COLOR=$(nvm_get_colors 2);
    CURRENT_COLOR=$(nvm_get_colors 3);
    NOT_INSTALLED_COLOR=$(nvm_get_colors 4);
    DEFAULT_COLOR=$(nvm_get_colors 5);
    LTS_COLOR=$(nvm_get_colors 6);
    NVM_CURRENT=$(nvm_ls_current);
    NVM_LATEST_LTS_COLOR=$(nvm_echo "${CURRENT_COLOR}" | command tr '0;' '1;');
    NVM_OLD_LTS_COLOR="${DEFAULT_COLOR}";
    local NVM_HAS_COLORS;
    if [ -z "${NVM_NO_COLORS-}" ] && nvm_has_colors; then
        NVM_HAS_COLORS=1;
    fi;
    local LTS_LENGTH;
    local LTS_FORMAT;
    nvm_echo "${1-}" | command sed '1!G;h;$!d' | command awk '{ if ($2 && $3 && $3 == "*") { print $1, "(Latest LTS: " $2 ")" } else if ($2) { print $1, "(LTS: " $2 ")" } else { print $1 } }' | command sed '1!G;h;$!d' | while read -r VERSION_LINE; do
        VERSION="${VERSION_LINE%% *}";
        LTS="${VERSION_LINE#* }";
        FORMAT='%15s';
        if [ "_${VERSION}" = "_${NVM_CURRENT}" ]; then
            if [ "${NVM_HAS_COLORS-}" = '1' ]; then
                FORMAT="\033[${CURRENT_COLOR}-> %12s\033[0m";
            else
                FORMAT='-> %12s *';
            fi;
        else
            if [ "${VERSION}" = "system" ]; then
                if [ "${NVM_HAS_COLORS-}" = '1' ]; then
                    FORMAT="\033[${SYSTEM_COLOR}%15s\033[0m";
                else
                    FORMAT='%15s *';
                fi;
            else
                if nvm_is_version_installed "${VERSION}"; then
                    if [ "${NVM_HAS_COLORS-}" = '1' ]; then
                        FORMAT="\033[${INSTALLED_COLOR}%15s\033[0m";
                    else
                        FORMAT='%15s *';
                    fi;
                fi;
            fi;
        fi;
        if [ "${LTS}" != "${VERSION}" ]; then
            case "${LTS}" in 
                *Latest*)
                    LTS="${LTS##Latest }";
                    LTS_LENGTH="${#LTS}";
                    if [ "${NVM_HAS_COLORS-}" = '1' ]; then
                        LTS_FORMAT="  \\033[${NVM_LATEST_LTS_COLOR}%${LTS_LENGTH}s\\033[0m";
                    else
                        LTS_FORMAT="  %${LTS_LENGTH}s";
                    fi
                ;;
                *)
                    LTS_LENGTH="${#LTS}";
                    if [ "${NVM_HAS_COLORS-}" = '1' ]; then
                        LTS_FORMAT="  \\033[${NVM_OLD_LTS_COLOR}%${LTS_LENGTH}s\\033[0m";
                    else
                        LTS_FORMAT="  %${LTS_LENGTH}s";
                    fi
                ;;
            esac;
            command printf -- "${FORMAT}${LTS_FORMAT}\\n" "${VERSION}" " ${LTS}";
        else
            command printf -- "${FORMAT}\\n" "${VERSION}";
        fi;
    done
}
nvm_process_parameters () 
{ 
    local NVM_AUTO_MODE;
    NVM_AUTO_MODE='use';
    while [ $# -ne 0 ]; do
        case "$1" in 
            --install)
                NVM_AUTO_MODE='install'
            ;;
            --no-use)
                NVM_AUTO_MODE='none'
            ;;
        esac;
        shift;
    done;
    nvm_auto "${NVM_AUTO_MODE}"
}
nvm_rc_version () 
{ 
    export NVM_RC_VERSION='';
    local NVMRC_PATH;
    NVMRC_PATH="$(nvm_find_nvmrc)";
    if [ ! -e "${NVMRC_PATH}" ]; then
        if [ "${NVM_SILENT:-0}" -ne 1 ]; then
            nvm_err "No .nvmrc file found";
        fi;
        return 1;
    fi;
    NVM_RC_VERSION="$(command head -n 1 "${NVMRC_PATH}" | command tr -d '\r')" || command printf '';
    if [ -z "${NVM_RC_VERSION}" ]; then
        if [ "${NVM_SILENT:-0}" -ne 1 ]; then
            nvm_err "Warning: empty .nvmrc file found at \"${NVMRC_PATH}\"";
        fi;
        return 2;
    fi;
    if [ "${NVM_SILENT:-0}" -ne 1 ]; then
        nvm_echo "Found '${NVMRC_PATH}' with version <${NVM_RC_VERSION}>";
    fi
}
nvm_remote_version () 
{ 
    local PATTERN;
    PATTERN="${1-}";
    local VERSION;
    if nvm_validate_implicit_alias "${PATTERN}" 2> /dev/null; then
        case "${PATTERN}" in 
            "$(nvm_iojs_prefix)")
                VERSION="$(NVM_LTS="${NVM_LTS-}" nvm_ls_remote_iojs | command tail -1)" && :
            ;;
            *)
                VERSION="$(NVM_LTS="${NVM_LTS-}" nvm_ls_remote "${PATTERN}")" && :
            ;;
        esac;
    else
        VERSION="$(NVM_LTS="${NVM_LTS-}" nvm_remote_versions "${PATTERN}" | command tail -1)";
    fi;
    if [ -n "${NVM_VERSION_ONLY-}" ]; then
        command awk 'BEGIN {
      n = split(ARGV[1], a);
      print a[1]
    }' "${VERSION}";
    else
        nvm_echo "${VERSION}";
    fi;
    if [ "${VERSION}" = 'N/A' ]; then
        return 3;
    fi
}
nvm_remote_versions () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    local PATTERN;
    PATTERN="${1-}";
    local NVM_FLAVOR;
    if [ -n "${NVM_LTS-}" ]; then
        NVM_FLAVOR="${NVM_NODE_PREFIX}";
    fi;
    case "${PATTERN}" in 
        "${NVM_IOJS_PREFIX}" | "io.js")
            NVM_FLAVOR="${NVM_IOJS_PREFIX}";
            unset PATTERN
        ;;
        "${NVM_NODE_PREFIX}")
            NVM_FLAVOR="${NVM_NODE_PREFIX}";
            unset PATTERN
        ;;
    esac;
    if nvm_validate_implicit_alias "${PATTERN-}" 2> /dev/null; then
        nvm_err 'Implicit aliases are not supported in nvm_remote_versions.';
        return 1;
    fi;
    local NVM_LS_REMOTE_EXIT_CODE;
    NVM_LS_REMOTE_EXIT_CODE=0;
    local NVM_LS_REMOTE_PRE_MERGED_OUTPUT;
    NVM_LS_REMOTE_PRE_MERGED_OUTPUT='';
    local NVM_LS_REMOTE_POST_MERGED_OUTPUT;
    NVM_LS_REMOTE_POST_MERGED_OUTPUT='';
    if [ -z "${NVM_FLAVOR-}" ] || [ "${NVM_FLAVOR-}" = "${NVM_NODE_PREFIX}" ]; then
        local NVM_LS_REMOTE_OUTPUT;
        NVM_LS_REMOTE_OUTPUT="$(NVM_LTS="${NVM_LTS-}" nvm_ls_remote "${PATTERN-}") " && :;
        NVM_LS_REMOTE_EXIT_CODE=$?;
        NVM_LS_REMOTE_PRE_MERGED_OUTPUT="${NVM_LS_REMOTE_OUTPUT%%v4\.0\.0*}";
        NVM_LS_REMOTE_POST_MERGED_OUTPUT="${NVM_LS_REMOTE_OUTPUT#$NVM_LS_REMOTE_PRE_MERGED_OUTPUT}";
    fi;
    local NVM_LS_REMOTE_IOJS_EXIT_CODE;
    NVM_LS_REMOTE_IOJS_EXIT_CODE=0;
    local NVM_LS_REMOTE_IOJS_OUTPUT;
    NVM_LS_REMOTE_IOJS_OUTPUT='';
    if [ -z "${NVM_LTS-}" ] && { 
        [ -z "${NVM_FLAVOR-}" ] || [ "${NVM_FLAVOR-}" = "${NVM_IOJS_PREFIX}" ]
    }; then
        NVM_LS_REMOTE_IOJS_OUTPUT=$(nvm_ls_remote_iojs "${PATTERN-}") && :;
        NVM_LS_REMOTE_IOJS_EXIT_CODE=$?;
    fi;
    VERSIONS="$(nvm_echo "${NVM_LS_REMOTE_PRE_MERGED_OUTPUT}
${NVM_LS_REMOTE_IOJS_OUTPUT}
${NVM_LS_REMOTE_POST_MERGED_OUTPUT}" | nvm_grep -v "N/A" | command sed '/^ *$/d')";
    if [ -z "${VERSIONS}" ]; then
        nvm_echo 'N/A';
        return 3;
    fi;
    nvm_echo "${VERSIONS}" | command sed 's/ *$//g';
    return $NVM_LS_REMOTE_EXIT_CODE || $NVM_LS_REMOTE_IOJS_EXIT_CODE
}
nvm_resolve_alias () 
{ 
    if [ -z "${1-}" ]; then
        return 1;
    fi;
    local PATTERN;
    PATTERN="${1-}";
    local ALIAS;
    ALIAS="${PATTERN}";
    local ALIAS_TEMP;
    local SEEN_ALIASES;
    SEEN_ALIASES="${ALIAS}";
    while true; do
        ALIAS_TEMP="$(nvm_alias "${ALIAS}" 2>/dev/null || nvm_echo)";
        if [ -z "${ALIAS_TEMP}" ]; then
            break;
        fi;
        if command printf "${SEEN_ALIASES}" | nvm_grep -q -e "^${ALIAS_TEMP}$"; then
            ALIAS="∞";
            break;
        fi;
        SEEN_ALIASES="${SEEN_ALIASES}\\n${ALIAS_TEMP}";
        ALIAS="${ALIAS_TEMP}";
    done;
    if [ -n "${ALIAS}" ] && [ "_${ALIAS}" != "_${PATTERN}" ]; then
        local NVM_IOJS_PREFIX;
        NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
        local NVM_NODE_PREFIX;
        NVM_NODE_PREFIX="$(nvm_node_prefix)";
        case "${ALIAS}" in 
            '∞' | "${NVM_IOJS_PREFIX}" | "${NVM_IOJS_PREFIX}-" | "${NVM_NODE_PREFIX}")
                nvm_echo "${ALIAS}"
            ;;
            *)
                nvm_ensure_version_prefix "${ALIAS}"
            ;;
        esac;
        return 0;
    fi;
    if nvm_validate_implicit_alias "${PATTERN}" 2> /dev/null; then
        local IMPLICIT;
        IMPLICIT="$(nvm_print_implicit_alias local "${PATTERN}" 2>/dev/null)";
        if [ -n "${IMPLICIT}" ]; then
            nvm_ensure_version_prefix "${IMPLICIT}";
        fi;
    fi;
    return 2
}
nvm_resolve_local_alias () 
{ 
    if [ -z "${1-}" ]; then
        return 1;
    fi;
    local VERSION;
    local EXIT_CODE;
    VERSION="$(nvm_resolve_alias "${1-}")";
    EXIT_CODE=$?;
    if [ -z "${VERSION}" ]; then
        return $EXIT_CODE;
    fi;
    if [ "_${VERSION}" != '_∞' ]; then
        nvm_version "${VERSION}";
    else
        nvm_echo "${VERSION}";
    fi
}
nvm_sanitize_path () 
{ 
    local SANITIZED_PATH;
    SANITIZED_PATH="${1-}";
    if [ "_${SANITIZED_PATH}" != "_${NVM_DIR}" ]; then
        SANITIZED_PATH="$(nvm_echo "${SANITIZED_PATH}" | command sed -e "s#${NVM_DIR}#\${NVM_DIR}#g")";
    fi;
    if [ "_${SANITIZED_PATH}" != "_${HOME}" ]; then
        SANITIZED_PATH="$(nvm_echo "${SANITIZED_PATH}" | command sed -e "s#${HOME}#\${HOME}#g")";
    fi;
    nvm_echo "${SANITIZED_PATH}"
}
nvm_set_colors () 
{ 
    if [ "${#1}" -eq 5 ] && nvm_echo "$1" | nvm_grep -E "^[rRgGbBcCyYmMkKeW]{1,}$" > /dev/null; then
        local INSTALLED_COLOR;
        local LTS_AND_SYSTEM_COLOR;
        local CURRENT_COLOR;
        local NOT_INSTALLED_COLOR;
        local DEFAULT_COLOR;
        INSTALLED_COLOR="$(echo "$1" | awk '{ print substr($0, 1, 1); }')";
        LTS_AND_SYSTEM_COLOR="$(echo "$1" | awk '{ print substr($0, 2, 1); }')";
        CURRENT_COLOR="$(echo "$1" | awk '{ print substr($0, 3, 1); }')";
        NOT_INSTALLED_COLOR="$(echo "$1" | awk '{ print substr($0, 4, 1); }')";
        DEFAULT_COLOR="$(echo "$1" | awk '{ print substr($0, 5, 1); }')";
        if ! nvm_has_colors; then
            nvm_echo "Setting colors to: ${INSTALLED_COLOR} ${LTS_AND_SYSTEM_COLOR} ${CURRENT_COLOR} ${NOT_INSTALLED_COLOR} ${DEFAULT_COLOR}";
            nvm_echo "WARNING: Colors may not display because they are not supported in this shell.";
        else
            nvm_echo_with_colors "Setting colors to: \033[$(nvm_print_color_code "${INSTALLED_COLOR}") ${INSTALLED_COLOR}\033[$(nvm_print_color_code "${LTS_AND_SYSTEM_COLOR}") ${LTS_AND_SYSTEM_COLOR}\033[$(nvm_print_color_code "${CURRENT_COLOR}") ${CURRENT_COLOR}\033[$(nvm_print_color_code "${NOT_INSTALLED_COLOR}") ${NOT_INSTALLED_COLOR}\033[$(nvm_print_color_code "${DEFAULT_COLOR}") ${DEFAULT_COLOR}\033[0m";
        fi;
        export NVM_COLORS="$1";
    else
        return 17;
    fi
}
nvm_stdout_is_terminal () 
{ 
    [ -t 1 ]
}
nvm_strip_iojs_prefix () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    if [ "${1-}" = "${NVM_IOJS_PREFIX}" ]; then
        nvm_echo;
    else
        nvm_echo "${1#${NVM_IOJS_PREFIX}-}";
    fi
}
nvm_strip_path () 
{ 
    if [ -z "${NVM_DIR-}" ]; then
        nvm_err '${NVM_DIR} not set!';
        return 1;
    fi;
    nvm_echo "${1-}" | command sed -e "s#${NVM_DIR}/[^/]*${2-}[^:]*:##g" -e "s#:${NVM_DIR}/[^/]*${2-}[^:]*##g" -e "s#${NVM_DIR}/[^/]*${2-}[^:]*##g" -e "s#${NVM_DIR}/versions/[^/]*/[^/]*${2-}[^:]*:##g" -e "s#:${NVM_DIR}/versions/[^/]*/[^/]*${2-}[^:]*##g" -e "s#${NVM_DIR}/versions/[^/]*/[^/]*${2-}[^:]*##g"
}
nvm_supports_xz () 
{ 
    if [ -z "${1-}" ]; then
        return 1;
    fi;
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    if [ "_${NVM_OS}" = '_darwin' ]; then
        local MACOS_VERSION;
        MACOS_VERSION="$(sw_vers -productVersion)";
        if nvm_version_greater "10.9.0" "${MACOS_VERSION}"; then
            return 1;
        fi;
    else
        if [ "_${NVM_OS}" = '_freebsd' ]; then
            if ! [ -e '/usr/lib/liblzma.so' ]; then
                return 1;
            fi;
        else
            if ! command which xz > /dev/null 2>&1; then
                return 1;
            fi;
        fi;
    fi;
    if nvm_is_merged_node_version "${1}"; then
        return 0;
    fi;
    if nvm_version_greater_than_or_equal_to "${1}" "0.12.10" && nvm_version_greater "0.13.0" "${1}"; then
        return 0;
    fi;
    if nvm_version_greater_than_or_equal_to "${1}" "0.10.42" && nvm_version_greater "0.11.0" "${1}"; then
        return 0;
    fi;
    case "${NVM_OS}" in 
        darwin)
            nvm_version_greater_than_or_equal_to "${1}" "2.3.2"
        ;;
        *)
            nvm_version_greater_than_or_equal_to "${1}" "1.0.0"
        ;;
    esac;
    return $?
}
nvm_tree_contains_path () 
{ 
    local tree;
    tree="${1-}";
    local node_path;
    node_path="${2-}";
    if [ "@${tree}@" = "@@" ] || [ "@${node_path}@" = "@@" ]; then
        nvm_err "both the tree and the node path are required";
        return 2;
    fi;
    local pathdir;
    pathdir=$(dirname "${node_path}");
    while [ "${pathdir}" != "" ] && [ "${pathdir}" != "." ] && [ "${pathdir}" != "/" ] && [ "${pathdir}" != "${tree}" ]; do
        pathdir=$(dirname "${pathdir}");
    done;
    [ "${pathdir}" = "${tree}" ]
}
nvm_use_if_needed () 
{ 
    if [ "_${1-}" = "_$(nvm_ls_current)" ]; then
        return;
    fi;
    nvm use "$@"
}
nvm_validate_implicit_alias () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    case "$1" in 
        "stable" | "unstable" | "${NVM_IOJS_PREFIX}" | "${NVM_NODE_PREFIX}")
            return
        ;;
        *)
            nvm_err "Only implicit aliases 'stable', 'unstable', '${NVM_IOJS_PREFIX}', and '${NVM_NODE_PREFIX}' are supported.";
            return 1
        ;;
    esac
}
nvm_version () 
{ 
    local PATTERN;
    PATTERN="${1-}";
    local VERSION;
    if [ -z "${PATTERN}" ]; then
        PATTERN='current';
    fi;
    if [ "${PATTERN}" = "current" ]; then
        nvm_ls_current;
        return $?;
    fi;
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    case "_${PATTERN}" in 
        "_${NVM_NODE_PREFIX}" | "_${NVM_NODE_PREFIX}-")
            PATTERN="stable"
        ;;
    esac;
    VERSION="$(nvm_ls "${PATTERN}" | command tail -1)";
    if [ -z "${VERSION}" ] || [ "_${VERSION}" = "_N/A" ]; then
        nvm_echo "N/A";
        return 3;
    fi;
    nvm_echo "${VERSION}"
}
nvm_version_dir () 
{ 
    local NVM_WHICH_DIR;
    NVM_WHICH_DIR="${1-}";
    if [ -z "${NVM_WHICH_DIR}" ] || [ "${NVM_WHICH_DIR}" = "new" ]; then
        nvm_echo "${NVM_DIR}/versions/node";
    else
        if [ "_${NVM_WHICH_DIR}" = "_iojs" ]; then
            nvm_echo "${NVM_DIR}/versions/io.js";
        else
            if [ "_${NVM_WHICH_DIR}" = "_old" ]; then
                nvm_echo "${NVM_DIR}";
            else
                nvm_err 'unknown version dir';
                return 3;
            fi;
        fi;
    fi
}
nvm_version_greater () 
{ 
    command awk 'BEGIN {
    if (ARGV[1] == "" || ARGV[2] == "") exit(1)
    split(ARGV[1], a, /\./);
    split(ARGV[2], b, /\./);
    for (i=1; i<=3; i++) {
      if (a[i] && a[i] !~ /^[0-9]+$/) exit(2);
      if (b[i] && b[i] !~ /^[0-9]+$/) { exit(0); }
      if (a[i] < b[i]) exit(3);
      else if (a[i] > b[i]) exit(0);
    }
    exit(4)
  }' "${1#v}" "${2#v}"
}
nvm_version_greater_than_or_equal_to () 
{ 
    command awk 'BEGIN {
    if (ARGV[1] == "" || ARGV[2] == "") exit(1)
    split(ARGV[1], a, /\./);
    split(ARGV[2], b, /\./);
    for (i=1; i<=3; i++) {
      if (a[i] && a[i] !~ /^[0-9]+$/) exit(2);
      if (a[i] < b[i]) exit(3);
      else if (a[i] > b[i]) exit(0);
    }
    exit(0)
  }' "${1#v}" "${2#v}"
}
nvm_version_path () 
{ 
    local VERSION;
    VERSION="${1-}";
    if [ -z "${VERSION}" ]; then
        nvm_err 'version is required';
        return 3;
    else
        if nvm_is_iojs_version "${VERSION}"; then
            nvm_echo "$(nvm_version_dir iojs)/$(nvm_strip_iojs_prefix "${VERSION}")";
        else
            if nvm_version_greater 0.12.0 "${VERSION}"; then
                nvm_echo "$(nvm_version_dir old)/${VERSION}";
            else
                nvm_echo "$(nvm_version_dir new)/${VERSION}";
            fi;
        fi;
    fi
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
